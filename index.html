<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Christmas Light Estimation Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-text-size-adjust: 100%;
            -moz-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            width: 100%;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            overflow: hidden;
        }

        h1 {
            text-align: center;
            color: #2c5f2d;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .customer-info {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .input-group input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
        }

        .input-group input:focus {
            outline: none;
            border-color: #2c5f2d;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            margin-bottom: 30px;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e0e0e0;
        }

        .section h2 {
            color: #2c5f2d;
            margin-bottom: 15px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .upload-area {
            border: 3px dashed #2c5f2d;
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            background: #f0f7f0;
            border-color: #1a3a1b;
        }

        .upload-area input {
            display: none;
        }

        .canvas-container {
            position: relative;
            overflow: auto;
            max-height: 600px;
            border: 2px solid #ddd;
            border-radius: 10px;
            background: #fff;
            width: 100%;
            max-width: 100%;
        }

        #measureCanvas {
            cursor: crosshair;
            display: block;
            max-width: 100%;
            height: auto;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .btn-primary {
            background: #2c5f2d;
            color: white;
        }

        .btn-primary:hover {
            background: #1a3a1b;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn-warning {
            background: #ffc107;
            color: #333;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .calibration-input {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .calibration-input input {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            width: 100px;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-weight: 600;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
        }

        .measurements-list {
            margin-top: 15px;
        }

        .measurement-item {
            background: white;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 4px solid;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .measurement-item.red { border-left-color: #ff0000; }
        .measurement-item.orange { border-left-color: #ff8800; }
        .measurement-item.green { border-left-color: #00cc00; }
        .measurement-item.blue { border-left-color: #0066ff; }
        .measurement-item.purple { border-left-color: #cc00cc; }
        .measurement-item.pink { border-left-color: #ff66cc; }

        .manual-measurement {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border: 2px solid #cc00cc;
        }

        .manual-measurement input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
        }

        .estimate-box {
            background: white;
            border: 3px solid #2c5f2d;
            border-radius: 10px;
            padding: 20px;
            position: sticky;
            top: 20px;
        }

        .estimate-box h2 {
            color: #2c5f2d;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.8em;
        }

        .estimate-item {
            padding: 12px;
            margin: 8px 0;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .estimate-item label {
            font-weight: 600;
            color: #333;
        }

        .estimate-item .value {
            font-weight: bold;
            color: #2c5f2d;
            font-size: 1.1em;
        }

        .estimate-total {
            margin-top: 20px;
            padding: 20px;
            background: #2c5f2d;
            color: white;
            border-radius: 10px;
            text-align: center;
        }

        .estimate-total h3 {
            font-size: 1.3em;
            margin-bottom: 10px;
        }

        .estimate-total .total-value {
            font-size: 2.5em;
            font-weight: bold;
        }

        .pricing-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .pricing-input input {
            width: 80px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            text-align: right;
        }

        .wreath-entry {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border: 2px solid #2c5f2d;
        }

        .wreath-entry input, .wreath-entry select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
        }

        .remove-btn {
            background: #dc3545;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 10;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #2c5f2d;
            color: white;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .zoom-btn:hover {
            background: #1a3a1b;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 30px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid #333;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .estimate-box {
                position: relative;
                top: 0;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.8em;
            }

            .subtitle {
                font-size: 1em;
            }

            .customer-info {
                grid-template-columns: 1fr;
                gap: 10px;
                padding: 15px;
            }

            .controls {
                flex-direction: column;
            }

            .controls button {
                width: 100%;
                margin-bottom: 5px;
            }

            .pricing-input {
                flex-wrap: wrap;
                gap: 5px;
            }

            .pricing-input input {
                width: 60px;
            }

            .legend {
                gap: 8px;
            }

            .legend-item {
                font-size: 0.9em;
            }

            .section {
                padding: 15px;
            }

            .section h2 {
                font-size: 1.3em;
            }

            .canvas-container {
                max-height: 400px;
                overflow: auto;
                -webkit-overflow-scrolling: touch;
            }

            #measureCanvas {
                max-width: 100%;
                height: auto;
                width: 100%;
                object-fit: contain;
            }

            .section {
                overflow: hidden;
            }

            .zoom-btn {
                width: 50px;
                height: 50px;
                font-size: 1.8em;
            }

            .estimate-box {
                padding: 15px;
                margin-bottom: 20px;
            }

            .estimate-box h2 {
                font-size: 1.5em;
            }

            .estimate-total .total-value {
                font-size: 2em;
            }

            button {
                padding: 14px 20px;
                font-size: 1em;
                min-height: 44px; /* Touch-friendly */
            }

            .input-group input {
                font-size: 16px; /* Prevent zoom on iOS */
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.5em;
            }

            .subtitle {
                font-size: 0.9em;
            }

            .section h2 {
                font-size: 1.2em;
            }

            .estimate-total .total-value {
                font-size: 1.8em;
            }

            .wreath-entry input, 
            .wreath-entry select,
            .manual-measurement input {
                font-size: 16px; /* Prevent zoom on iOS */
            }

            .zoom-controls {
                top: 5px;
                right: 5px;
            }

            .zoom-btn {
                width: 45px;
                height: 45px;
            }
        }

        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            /* This targets touch devices */
            button {
                min-height: 48px;
                padding: 16px 24px;
            }

            .measurement-item {
                padding: 12px;
            }

            .remove-btn {
                min-height: 40px;
                padding: 8px 12px;
            }

            #measureCanvas {
                touch-action: none; /* Prevent default touch behaviors */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÑ Christmas Light Estimation Tool üéÑ</h1>
        <p class="subtitle">Professional Roof Measuring & Quote Generator</p>

        <!-- Load Project Button at Top -->
        <div style="text-align: center; margin-bottom: 20px;">
            <button class="btn-primary" onclick="loadProject()" style="background: #17a2b8; font-size: 1.1em; padding: 15px 30px;">
                üìÇ Load Saved Project
            </button>
            <p style="color: #666; margin-top: 8px; font-size: 0.9em;">Load a previous project to view or edit measurements</p>
        </div>

        <!-- Customer Information -->
        <div class="customer-info">
            <div class="input-group">
                <label>Customer Name:</label>
                <input type="text" id="customerName" placeholder="Enter customer name">
            </div>
            <div class="input-group">
                <label>Address:</label>
                <input type="text" id="customerAddress" placeholder="Enter property address">
            </div>
        </div>

        <div class="main-layout">
            <!-- Left Panel -->
            <div class="left-panel">
                <!-- Image Upload Section -->
                <div class="section" id="uploadSection">
                    <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" onclick="toggleUploadSection()">
                        <h2>üì∑ Step 1: Upload Photo</h2>
                        <span id="uploadToggle" style="font-size: 1.5em; font-weight: bold;">‚ñº</span>
                    </div>
                    <div id="uploadContent">
                        <p style="color: #666; margin-bottom: 15px; line-height: 1.6;">
                            Upload a full photo of the house with the roof clearly visible. Include the entire structure you want to measure for best results.
                        </p>
                        <div class="upload-area" onclick="document.getElementById('imageUpload').click()">
                            <input type="file" id="imageUpload" accept="image/*">
                            <p style="font-size: 1.2em; color: #2c5f2d; font-weight: 600;">Click to upload image</p>
                            <p style="color: #666; margin-top: 10px;">Supports JPG, PNG, WEBP</p>
                        </div>
                    </div>
                </div>

                <!-- Canvas Section -->
                <div class="section" id="canvasSection" style="display: none;">
                    <h2>üìè Step 2: Calibrate & Measure</h2>
                    
                    <!-- Collapsible Instructions -->
                    <div id="instructionsCollapsible" style="display: none; margin-bottom: 15px;">
                        <button onclick="toggleInstructions()" style="width: 100%; text-align: left; background: #e8f5e9; border: 2px solid #4caf50; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 600; color: #2c5f2d; display: flex; justify-content: space-between; align-items: center;">
                            <span>‚ÑπÔ∏è How to Add Measurement Points</span>
                            <span id="instructionsToggle">‚ñº</span>
                        </button>
                        <div id="instructionsContent" style="display: none; background: #f0f8f0; border: 2px solid #4caf50; border-top: none; padding: 15px; border-radius: 0 0 8px 8px; line-height: 1.8;">
                            <p style="margin-bottom: 10px;"><strong>How to measure your roofline:</strong></p>
                            <ol style="margin-left: 20px; margin-bottom: 15px;">
                                <li>Click along the roofline where you want lights installed</li>
                                <li>Each click adds a numbered point</li>
                                <li>Points automatically connect with lines</li>
                                <li>Distance in feet shows on each segment</li>
                            </ol>
                            
                            <p style="margin-bottom: 10px;"><strong>Tips:</strong></p>
                            <ul style="margin-left: 20px; margin-bottom: 15px;">
                                <li><strong>Move a point:</strong> Click and drag any numbered point</li>
                                <li><strong>Delete a segment:</strong> Click the ‚ùå next to the footage label</li>
                                <li><strong>New section:</strong> Click "Start New Section" for different roof levels</li>
                                <li><strong>Zoom:</strong> Use + and - buttons to zoom in/out</li>
                                <li><strong>Undo/Redo:</strong> Made a mistake? Use the undo/redo buttons</li>
                            </ul>
                            
                            <p style="color: #2c5f2d; font-weight: bold;">Start clicking on your roof to begin measuring! üéØ</p>
                        </div>
                    </div>
                    
                    <div id="calibrationStatus" class="status info">
                        Click two points on a known distance (door, window, etc.)
                    </div>

                    <div class="calibration-input">
                        <label>Known Distance:</label>
                        <input type="number" id="knownDistance" value="8" step="0.5" min="0">
                        <span>feet</span>
                        <button class="btn-warning" onclick="resetCalibration()">Reset Calibration</button>
                    </div>

                    <div class="canvas-container" style="margin-top: 15px; position: relative;">
                        <div class="zoom-controls">
                            <button class="zoom-btn" onclick="zoomIn()">+</button>
                            <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
                        </div>
                        <canvas id="measureCanvas"></canvas>
                    </div>

                    <div class="legend" id="sectionLegend">
                        <!-- Legend will be dynamically populated -->
                    </div>

                    <!-- Tier Selection -->
                    <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; margin: 15px 0; border: 2px solid #0066ff;">
                        <h3 style="font-size: 1em; margin-bottom: 10px; color: #333;">üì¶ Measurement Tiers/Options</h3>
                        <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">Select which tier you're measuring for. Each tier saves separate measurements, wreaths, and wraps.</p>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 10px;">
                            <button id="tierBtn1" class="btn-primary" onclick="switchToTier(1)" style="padding: 12px; font-weight: 600; background: #28a745; border: 3px solid #28a745;">
                                Basic (Active)
                            </button>
                            <button id="tierBtn2" class="btn-secondary" onclick="switchToTier(2)" style="padding: 12px; font-weight: 600;">
                                Standard
                            </button>
                            <button id="tierBtn3" class="btn-secondary" onclick="switchToTier(3)" style="padding: 12px; font-weight: 600;">
                                Premium
                            </button>
                        </div>
                        
                        <div style="background: white; padding: 10px; border-radius: 5px; border: 2px solid #ddd;">
                            <label style="display: block; font-weight: 600; margin-bottom: 5px;">Package Name:</label>
                            <input type="text" id="currentTierName" value="Basic Package - Front Only" 
                                   style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;" 
                                   onchange="updateTierName()">
                            <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                                Example: "Front Only", "Front + Sides", "Full House + Premium"
                            </p>
                        </div>
                    </div>

                    <div class="controls">
                        <button class="btn-primary" onclick="startNewSection()">Start New Section</button>
                        <button class="btn-warning" onclick="undoPoint()">‚Ü∂ Undo Point</button>
                        <button class="btn-warning" onclick="redoPoint()">‚Ü∑ Redo Point</button>
                        <button class="btn-secondary" onclick="clearAll()">Clear All</button>
                        <button class="btn-primary" onclick="saveProject()" style="background: #17a2b8;">üíæ Save Project</button>
                        <button id="mobileModeBtn" class="btn-secondary" onclick="toggleMobileMode()" style="background: #6c757d;">
                            üì± Enable Mobile Mode
                        </button>
                    </div>

                    <div class="measurements-list" id="measurementsList"></div>
                </div>

                <!-- Manual Measurements -->
                <div class="section">
                    <h2>‚úçÔ∏è Manual Measurements</h2>
                    <p style="color: #666; margin-bottom: 10px;">Add unmeasurable sides (back walls, hidden areas, etc.)</p>
                    <div id="manualMeasurements"></div>
                    <button class="btn-primary" onclick="addManualMeasurement()">+ Add Manual Entry</button>
                </div>

                <!-- Wreaths Section -->
                <div class="section">
                    <h2>üåø Wreaths</h2>
                    <div id="wreathsList"></div>
                    <button class="btn-primary" onclick="addWreath()">+ Add Wreath</button>
                </div>

                <!-- Column & Shrub Wraps -->
                <div class="section">
                    <h2>üå≤ Column & Shrub Wraps</h2>
                    <div class="pricing-input" style="margin-bottom: 15px;">
                        <label>Column Wraps:</label>
                        <input type="number" id="columnCount" value="0" min="0" onchange="updateEstimate()">
                        <span>@ $</span>
                        <input type="number" id="columnPrice" value="40" step="1" min="0" onchange="updateEstimate()">
                        <span>per strand</span>
                    </div>
                    <div class="pricing-input">
                        <label>Shrub Wraps:</label>
                        <input type="number" id="shrubCount" value="0" min="0" onchange="updateEstimate()">
                        <span>@ $</span>
                        <input type="number" id="shrubPrice" value="30" step="1" min="0" onchange="updateEstimate()">
                        <span>per strand</span>
                    </div>
                </div>
            </div>

            <!-- Right Panel - Estimate -->
            <div>
                <div class="estimate-box">
                    <h2>üí∞ ESTIMATE</h2>

                    <div class="estimate-item">
                        <div>
                            <label>Roofline Lights</label>
                            <div style="font-size: 0.9em; color: #666;" id="rooflineDetails">0 ft</div>
                        </div>
                        <div class="value" id="rooflineTotal">$0.00</div>
                    </div>

                    <div class="pricing-input" style="margin-left: 20px; margin-bottom: 15px;">
                        <span>Price per foot: $</span>
                        <input type="number" id="pricePerFoot" value="8" step="0.5" min="0" onchange="updateEstimate()">
                    </div>

                    <div class="estimate-item">
                        <div>
                            <label>Wreaths</label>
                            <div style="font-size: 0.9em; color: #666;" id="wreathDetails">None</div>
                        </div>
                        <div class="value" id="wreathTotal">$0.00</div>
                    </div>

                    <div class="estimate-item">
                        <div>
                            <label>Column Wraps</label>
                            <div style="font-size: 0.9em; color: #666;" id="columnDetails">0 wraps</div>
                        </div>
                        <div class="value" id="columnTotal">$0.00</div>
                    </div>

                    <div class="estimate-item">
                        <div>
                            <label>Shrub Wraps</label>
                            <div style="font-size: 0.9em; color: #666;" id="shrubDetails">0 wraps</div>
                        </div>
                        <div class="value" id="shrubTotal">$0.00</div>
                    </div>

                    <div class="estimate-total">
                        <h3>TOTAL ESTIMATE</h3>
                        <div class="total-value" id="grandTotal">$0.00</div>
                    </div>

                    <!-- Price Comparison Tool (Reference Only - Not Exported) -->
                    <div style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 8px; border: 2px solid #ffc107;">
                        <h3 style="font-size: 1em; margin-bottom: 10px; color: #333;">üìä Price Comparison (Reference Only)</h3>
                        <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">Compare current estimate at different price points (for internal use only)</p>
                        
                        <label style="display: flex; align-items: center; margin-bottom: 10px; cursor: pointer;">
                            <input type="checkbox" id="showPriceComparison" onchange="togglePriceComparison()" style="margin-right: 8px; width: 18px; height: 18px;">
                            <span style="font-weight: 600;">Show Price Comparison</span>
                        </label>
                        
                        <div id="priceComparisonContainer" style="display: none;">
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                                <div style="background: white; padding: 10px; border-radius: 5px; border: 2px solid #ddd; text-align: center;">
                                    <div style="font-weight: 600; margin-bottom: 5px;">Low ($6/ft)</div>
                                    <div id="priceCompLow" style="font-size: 1.2em; color: #28a745;">$0.00</div>
                                </div>
                                <div style="background: white; padding: 10px; border-radius: 5px; border: 2px solid #ddd; text-align: center;">
                                    <div style="font-weight: 600; margin-bottom: 5px;">Mid ($8/ft)</div>
                                    <div id="priceCompMid" style="font-size: 1.2em; color: #0066ff;">$0.00</div>
                                </div>
                                <div style="background: white; padding: 10px; border-radius: 5px; border: 2px solid #ddd; text-align: center;">
                                    <div style="font-weight: 600; margin-bottom: 5px;">High ($10/ft)</div>
                                    <div id="priceCompHigh" style="font-size: 1.2em; color: #dc3545;">$0.00</div>
                                </div>
                            </div>
                            <p style="font-size: 0.85em; color: #666; margin-top: 10px; font-style: italic;">
                                ‚ö†Ô∏è Not exported - for reference only
                            </p>
                        </div>
                    </div>

                    <!-- Export Options -->
                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <h4 style="margin-bottom: 10px; color: #333;">üìÑ Export Options</h4>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Logo (optional):</label>
                            <div style="display: flex; gap: 10px; align-items: flex-start;">
                                <input type="file" id="logoUpload" accept="image/*" 
                                       style="flex: 1; padding: 8px; border: 2px solid #ddd; border-radius: 5px; font-size: 14px;" 
                                       onchange="saveLogo()">
                                <button class="btn-secondary" onclick="clearLogo()" style="padding: 8px 12px; white-space: nowrap; font-size: 14px;">Clear</button>
                            </div>
                            <p style="font-size: 0.85em; color: #666; margin-top: 5px;">Logo saved until cleared - appears at bottom of PDF</p>
                            <div id="logoPreview" style="margin-top: 10px; display: none;">
                                <img id="logoPreviewImg" style="max-width: 100px; max-height: 60px; border: 2px solid #ddd; border-radius: 5px;">
                                <p style="color: #28a745; font-size: 0.85em; margin-top: 5px;">‚úì Logo saved and ready</p>
                            </div>
                        </div>

                        <div style="margin-bottom: 10px;">
                            <strong style="display: block; margin-bottom: 8px; color: #555;">Show on PDF:</strong>
                            
                            <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer;">
                                <input type="checkbox" id="exportShowMeasurements" checked 
                                       style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                <span>Show measurements (footage amounts)</span>
                            </label>
                            
                            <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer;">
                                <input type="checkbox" id="exportShowPricePerFoot" checked 
                                       style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                <span>Show price per foot</span>
                            </label>
                            
                            <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer;">
                                <input type="checkbox" id="exportShowWreathPrices" checked 
                                       style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                <span>Show individual wreath prices</span>
                            </label>
                            
                            <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer;">
                                <input type="checkbox" id="exportShowWrapPrices" checked 
                                       style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                                <span>Show column/shrub wrap unit prices</span>
                            </label>
                        </div>
                        
                        <p style="font-size: 0.85em; color: #666; font-style: italic;">
                            üí° Uncheck items to hide pricing details from customer PDF
                        </p>
                    </div>

                    <button class="btn-primary" onclick="exportSinglePDF()" style="width: 100%; margin-top: 20px; padding: 15px; font-size: 1.1em;">
                        üìÑ Export Basic Only
                    </button>
                    
                    <button class="btn-primary" onclick="exportAllTiersPDF()" style="width: 100%; margin-top: 10px; padding: 15px; font-size: 1.1em; background: #17a2b8;">
                        üìë Export All Tiers (Multi-Page PDF)
                    </button>
                    
                    <p style="text-align: center; font-size: 0.85em; color: #666; margin-top: 8px;">
                        Each tier exports with its own measurements and pricing
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let canvas, ctx;
        let image = null;
        let originalImageData = null; // Store original image without drawings
        let savedLogoData = localStorage.getItem('christmasLightLogo') || null; // Persistent logo storage
        let zoomLevel = 1;
        let calibrationPoints = [];
        let calibrationFactor = null;
        let isCalibrated = false;
        
        // History for undo/redo
        let history = [];
        let historyIndex = -1;
        
        // Mobile mode override
        let forceMobileMode = false;
        
        let sections = [];
        
        let currentSectionIndex = 0;
        let manualMeasurements = [];
        let wreaths = [];
        
        // Tier system - each tier has its own measurements
        let currentTier = 1;
        let tiers = {
            1: {
                name: 'Basic Package - Front Only',
                sections: [],
                manualMeasurements: [],
                wreaths: [],
                columnCount: 0,
                columnPrice: 40,
                shrubCount: 0,
                shrubPrice: 30
            },
            2: {
                name: 'Standard Package - Front + Sides',
                sections: [],
                manualMeasurements: [],
                wreaths: [],
                columnCount: 0,
                columnPrice: 40,
                shrubCount: 0,
                shrubPrice: 30
            },
            3: {
                name: 'Premium Package - Full House',
                sections: [],
                manualMeasurements: [],
                wreaths: [],
                columnCount: 0,
                columnPrice: 40,
                shrubCount: 0,
                shrubPrice: 30
            }
        };

        // Color palette for sections - will cycle through these
        const sectionColors = [
            '#ff0000', // red
            '#ff8800', // orange
            '#00cc00', // green
            '#0066ff', // blue
            '#cc00cc', // purple
            '#ff66cc', // pink
            '#00cccc', // cyan
            '#ffcc00', // yellow
            '#cc0000', // dark red
            '#0088ff', // light blue
            '#ff0066', // hot pink
            '#66cc00', // lime
            '#9900cc', // violet
            '#ff6600', // orange-red
            '#00cc66', // teal
            '#cc6600'  // brown
        ];

        // Initialize with first section
        function initializeFirstSection() {
            if (sections.length === 0) {
                sections.push({
                    color: sectionColors[0],
                    name: 'Section 1',
                    points: [],
                    lengths: [],
                    deleteAreas: []
                });
            }
        }

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                originalImageData = event.target.result; // Store original image data
                image = new Image();
                image.onload = function() {
                    setupCanvas();
                    document.getElementById('canvasSection').style.display = 'block';
                    document.getElementById('instructionsCollapsible').style.display = 'block';
                    
                    // Auto-collapse Step 1 to save space
                    document.getElementById('uploadContent').style.display = 'none';
                    document.getElementById('uploadToggle').textContent = '‚ñ∂';
                };
                image.src = originalImageData;
            };
            reader.readAsDataURL(file);
        }

        function toggleInstructions() {
            const content = document.getElementById('instructionsContent');
            const toggle = document.getElementById('instructionsToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñ≤';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñº';
            }
        }

        function toggleUploadSection() {
            const content = document.getElementById('uploadContent');
            const toggle = document.getElementById('uploadToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        function toggleMobileMode() {
            forceMobileMode = !forceMobileMode;
            const btn = document.getElementById('mobileModeBtn');
            if (forceMobileMode) {
                btn.textContent = 'üñ•Ô∏è Disable Mobile Mode';
                btn.style.background = '#28a745';
            } else {
                btn.textContent = 'üì± Enable Mobile Mode';
                btn.style.background = '#6c757d';
            }
            // Redraw with new point sizes
            drawCanvas();
        }

        // Logo Management Functions
        function saveLogo() {
            const logoFile = document.getElementById('logoUpload').files[0];
            if (!logoFile) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                savedLogoData = e.target.result;
                localStorage.setItem('christmasLightLogo', savedLogoData);
                
                // Show preview
                document.getElementById('logoPreviewImg').src = savedLogoData;
                document.getElementById('logoPreview').style.display = 'block';
            };
            reader.readAsDataURL(logoFile);
        }

        function clearLogo() {
            savedLogoData = null;
            localStorage.removeItem('christmasLightLogo');
            document.getElementById('logoUpload').value = '';
            document.getElementById('logoPreview').style.display = 'none';
            alert('Logo cleared!');
        }

        // Pricing Options Functions
        function togglePriceComparison() {
            const enabled = document.getElementById('showPriceComparison').checked;
            const container = document.getElementById('priceComparisonContainer');
            
            if (enabled) {
                container.style.display = 'block';
                updatePriceComparison();
            } else {
                container.style.display = 'none';
            }
        }

        function updatePriceComparison() {
            const rooflineFootage = sections.reduce((sum, s) => 
                sum + s.lengths.reduce((s2, l) => s2 + l, 0), 0) + 
                manualMeasurements.reduce((sum, m) => sum + m.length, 0);
            
            const wreathTotal = wreaths.reduce((sum, w) => sum + (w.quantity * w.price), 0);
            const columnCount = parseInt(document.getElementById('columnCount').value) || 0;
            const columnPrice = parseFloat(document.getElementById('columnPrice').value) || 0;
            const shrubCount = parseInt(document.getElementById('shrubCount').value) || 0;
            const shrubPrice = parseFloat(document.getElementById('shrubPrice').value) || 0;
            const otherCosts = wreathTotal + (columnCount * columnPrice) + (shrubCount * shrubPrice);
            
            document.getElementById('priceCompLow').textContent = '$' + ((rooflineFootage * 6) + otherCosts).toFixed(2);
            document.getElementById('priceCompMid').textContent = '$' + ((rooflineFootage * 8) + otherCosts).toFixed(2);
            document.getElementById('priceCompHigh').textContent = '$' + ((rooflineFootage * 10) + otherCosts).toFixed(2);
        }

        // Tier Management Functions
        function switchToTier(tierNum) {
            // Save current tier data
            tiers[currentTier].sections = JSON.parse(JSON.stringify(sections));
            tiers[currentTier].manualMeasurements = JSON.parse(JSON.stringify(manualMeasurements));
            tiers[currentTier].wreaths = JSON.parse(JSON.stringify(wreaths));
            tiers[currentTier].columnCount = parseInt(document.getElementById('columnCount').value) || 0;
            tiers[currentTier].columnPrice = parseFloat(document.getElementById('columnPrice').value) || 0;
            tiers[currentTier].shrubCount = parseInt(document.getElementById('shrubCount').value) || 0;
            tiers[currentTier].shrubPrice = parseFloat(document.getElementById('shrubPrice').value) || 0;
            
            // Load new tier data
            currentTier = tierNum;
            sections = JSON.parse(JSON.stringify(tiers[tierNum].sections));
            manualMeasurements = JSON.parse(JSON.stringify(tiers[tierNum].manualMeasurements));
            wreaths = JSON.parse(JSON.stringify(tiers[tierNum].wreaths));
            
            // Update UI
            document.getElementById('columnCount').value = tiers[tierNum].columnCount;
            document.getElementById('columnPrice').value = tiers[tierNum].columnPrice;
            document.getElementById('shrubCount').value = tiers[tierNum].shrubCount;
            document.getElementById('shrubPrice').value = tiers[tierNum].shrubPrice;
            document.getElementById('currentTierName').value = tiers[tierNum].name;
            
            // Update button styles
            const tierLabels = ['Basic', 'Standard', 'Premium'];
            for (let i = 1; i <= 3; i++) {
                const btn = document.getElementById(`tierBtn${i}`);
                if (i === tierNum) {
                    btn.className = 'btn-primary';
                    btn.style.background = '#28a745';
                    btn.style.border = '3px solid #28a745';
                    btn.textContent = `${tierLabels[i-1]} (Active)`;
                } else {
                    btn.className = 'btn-secondary';
                    btn.style.background = '';
                    btn.style.border = '';
                    btn.textContent = tierLabels[i-1];
                }
            }
            
            // Initialize sections if empty
            if (sections.length === 0) {
                initializeFirstSection();
                currentSectionIndex = 0; // Set to first section
            } else {
                // Set to last section or 0 if exists
                currentSectionIndex = sections.length - 1;
            }
            
            // Redraw and update
            drawCanvas();
            updateMeasurementsList();
            updateEstimate();
            renderWreaths();
            renderManualMeasurements();
            updateLegend(); // Update legend to show correct sections
            
            // Auto-update price comparison if visible
            if (document.getElementById('showPriceComparison').checked) {
                updatePriceComparison();
            }
        }

        function updateTierName() {
            tiers[currentTier].name = document.getElementById('currentTierName').value;
        }

        // Load saved logo on page load
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('imageUpload').addEventListener('change', handleImageUpload);
            
            // Show logo preview if exists
            if (savedLogoData) {
                document.getElementById('logoPreviewImg').src = savedLogoData;
                document.getElementById('logoPreview').style.display = 'block';
            }
        });

        // Export as Image Function

        function setupCanvas() {
            canvas = document.getElementById('measureCanvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas to actual image dimensions
            canvas.width = image.width;
            canvas.height = image.height;
            
            // CSS will automatically scale it to fit container
            
            // Initialize first section if needed
            initializeFirstSection();
            
            drawCanvas();
            
            // Mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('click', handleCanvasClick);
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        // Touch event handlers with improved coordinate handling
        let lastTouchTime = 0;
        let lastTapLocation = null;

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            
            // Store tap location for debugging
            lastTapLocation = { x: touch.clientX, y: touch.clientY };
            
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY,
                bubbles: true
            });
            canvas.dispatchEvent(mouseEvent);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY,
                bubbles: true
            });
            canvas.dispatchEvent(mouseEvent);
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            
            // Handle tap as click with proper timing
            const now = Date.now();
            const timeSinceLastTouch = now - lastTouchTime;
            
            if (e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                
                // Always trigger click for taps (not drags)
                if (lastTapLocation) {
                    const distance = Math.sqrt(
                        Math.pow(touch.clientX - lastTapLocation.x, 2) + 
                        Math.pow(touch.clientY - lastTapLocation.y, 2)
                    );
                    
                    // If didn't move much, it's a tap
                    if (distance < 10) {
                        const clickEvent = new MouseEvent('click', {
                            clientX: touch.clientX,
                            clientY: touch.clientY,
                            bubbles: true,
                            cancelable: true
                        });
                        canvas.dispatchEvent(clickEvent);
                    }
                }
                
                const mouseUpEvent = new MouseEvent('mouseup', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    bubbles: true
                });
                canvas.dispatchEvent(mouseUpEvent);
            }
            
            lastTapLocation = null;
            lastTouchTime = now;
        }

        let draggingPoint = null;
        let dragStartPos = null;

        function handleMouseDown(e) {
            if (!isCalibrated) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            // Much larger detection radius on mobile to match huge points
            const isMobile = forceMobileMode || window.innerWidth < 768;
            const detectionRadius = isMobile ? 80 : 12;
            
            // Check if clicking on a point to drag
            for (let sectionIdx = 0; sectionIdx < sections.length; sectionIdx++) {
                const section = sections[sectionIdx];
                for (let pointIdx = 0; pointIdx < section.points.length; pointIdx++) {
                    const point = section.points[pointIdx];
                    const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                    
                    if (distance <= detectionRadius) { // Larger hit area on mobile
                        draggingPoint = { sectionIdx, pointIdx };
                        dragStartPos = { x, y };
                        canvas.style.cursor = 'move';
                        e.preventDefault();
                        return;
                    }
                }
            }
        }

        function handleMouseMove(e) {
            if (!draggingPoint) {
                // Update cursor when hovering over points
                if (isCalibrated) {
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    
                    const isMobile = forceMobileMode || window.innerWidth < 768;
                    const detectionRadius = isMobile ? 80 : 12;
                    
                    let overPoint = false;
                    for (let sectionIdx = 0; sectionIdx < sections.length; sectionIdx++) {
                        const section = sections[sectionIdx];
                        for (let pointIdx = 0; pointIdx < section.points.length; pointIdx++) {
                            const point = section.points[pointIdx];
                            const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                            
                            if (distance <= detectionRadius) {
                                overPoint = true;
                                break;
                            }
                        }
                        if (overPoint) break;
                    }
                    canvas.style.cursor = overPoint ? 'move' : 'crosshair';
                }
                return;
            }
            
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            // Update point position
            const section = sections[draggingPoint.sectionIdx];
            section.points[draggingPoint.pointIdx] = { x, y };
            
            // Recalculate lengths for affected segments
            const pointIdx = draggingPoint.pointIdx;
            
            // Recalculate segment before this point
            if (pointIdx > 0) {
                const p1 = section.points[pointIdx - 1];
                const p2 = section.points[pointIdx];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                section.lengths[pointIdx - 1] = pixelDistance * calibrationFactor;
            }
            
            // Recalculate segment after this point
            if (pointIdx < section.points.length - 1) {
                const p1 = section.points[pointIdx];
                const p2 = section.points[pointIdx + 1];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                section.lengths[pointIdx] = pixelDistance * calibrationFactor;
            }
            
            drawCanvas();
        }

        function handleMouseUp(e) {
            if (draggingPoint) {
                e.preventDefault();
                saveState(); // Save state after dragging
                draggingPoint = null;
                dragStartPos = null;
                canvas.style.cursor = 'crosshair';
                updateMeasurementsList();
                updateEstimate();
            }
        }

        function drawCanvas() {
            // Always start with a completely clean canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Redraw the base image
            ctx.drawImage(image, 0, 0);

            // Calculate point size based on viewport (EXTREMELY large on mobile for visibility)
            const isMobile = forceMobileMode || window.innerWidth < 768;
            const calibrationPointSize = isMobile ? 40 : 6;
            const measurePointSize = isMobile ? 50 : 8;
            const pointNumberFontSize = isMobile ? 32 : 12;
            const lineWidth = isMobile ? 12 : 3;

            // Draw calibration line
            if (calibrationPoints.length === 2) {
                ctx.strokeStyle = '#0066ff';
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.moveTo(calibrationPoints[0].x, calibrationPoints[0].y);
                ctx.lineTo(calibrationPoints[1].x, calibrationPoints[1].y);
                ctx.stroke();
                
                // Draw calibration points
                calibrationPoints.forEach(point => {
                    // Yellow halo ONLY on mobile
                    if (isMobile) {
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, calibrationPointSize + 10, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#0066ff';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, calibrationPointSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Thick white border for visibility
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = isMobile ? 6 : 2;
                    ctx.stroke();
                });
            }

            // Draw all sections - only draw what exists in the points array
            sections.forEach((section, sectionIdx) => {
                if (section.points.length === 0) return;

                ctx.strokeStyle = section.color;
                ctx.lineWidth = lineWidth;
                ctx.fillStyle = section.color;

                // Draw lines - VERY THICK on mobile
                for (let i = 0; i < section.points.length - 1; i++) {
                    if (section.points[i] && section.points[i + 1]) {
                        ctx.beginPath();
                        ctx.moveTo(section.points[i].x, section.points[i].y);
                        ctx.lineTo(section.points[i + 1].x, section.points[i + 1].y);
                        ctx.stroke();
                    }
                }

                // Draw points with numbers
                section.points.forEach((point, idx) => {
                    if (point) {
                        // Yellow halo ONLY on mobile
                        if (isMobile) {
                            ctx.fillStyle = '#ffff00';
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, measurePointSize + 10, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.fillStyle = section.color;
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, measurePointSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Thick white border for visibility
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = isMobile ? 6 : 2;
                        ctx.stroke();
                        
                        // Black text outline for better visibility on mobile
                        if (isMobile) {
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = 3;
                            ctx.font = `bold ${pointNumberFontSize}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.strokeText((idx + 1).toString(), point.x, point.y);
                        }
                        
                        ctx.fillStyle = 'white';
                        ctx.font = `bold ${pointNumberFontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText((idx + 1).toString(), point.x, point.y);
                    }
                });
            });

            // Draw length labels with X delete buttons on top of everything
            sections.forEach((section, sectionIdx) => {
                if (section.points.length === 0) return;
                
                // Clear delete areas for this section
                section.deleteAreas = [];

                // Larger labels and buttons on mobile
                const labelFontSize = isMobile ? 14 : 11;
                const xButtonSize = isMobile ? 24 : 16;
                const boxHeight = isMobile ? 24 : 16;

                for (let i = 0; i < section.points.length - 1; i++) {
                    if (section.lengths[i] && section.points[i] && section.points[i + 1]) {
                        const midX = (section.points[i].x + section.points[i + 1].x) / 2;
                        const midY = (section.points[i].y + section.points[i + 1].y) / 2;
                        
                        const labelText = section.lengths[i].toFixed(1) + ' ft';
                        ctx.font = `bold ${labelFontSize}px Arial`;
                        const textWidth = ctx.measureText(labelText).width;
                        
                        // Draw white background with rounded corners
                        const padding = isMobile ? 6 : 4;
                        const boxWidth = textWidth + padding * 2 + xButtonSize + 4;
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        ctx.beginPath();
                        ctx.roundRect(midX - boxWidth/2, midY - boxHeight/2, boxWidth, boxHeight, 3);
                        ctx.fill();
                        
                        // Draw text in dark color
                        ctx.fillStyle = '#333';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(labelText, midX - xButtonSize/2 - 2, midY);
                        
                        // Draw X button - larger on mobile
                        const xButtonX = midX + boxWidth/2 - xButtonSize/2 - 2;
                        const xButtonY = midY - xButtonSize/2;
                        
                        // Red circle background
                        ctx.fillStyle = '#dc3545';
                        ctx.beginPath();
                        const circleRadius = isMobile ? 11 : 7;
                        ctx.arc(xButtonX + xButtonSize/2, xButtonY + xButtonSize/2, circleRadius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // White X
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = isMobile ? 3 : 2;
                        const xOffset = isMobile ? 6 : 4;
                        ctx.beginPath();
                        ctx.moveTo(xButtonX + xOffset, xButtonY + xOffset);
                        ctx.lineTo(xButtonX + xButtonSize - xOffset, xButtonY + xButtonSize - xOffset);
                        ctx.moveTo(xButtonX + xButtonSize - xOffset, xButtonY + xOffset);
                        ctx.lineTo(xButtonX + xOffset, xButtonY + xButtonSize - xOffset);
                        ctx.stroke();
                        
                        // Store the clickable area for this segment - larger hit area on mobile
                        section.deleteAreas[i] = {
                            x: xButtonX - (isMobile ? 5 : 0),
                            y: xButtonY - (isMobile ? 5 : 0),
                            width: xButtonSize + (isMobile ? 10 : 0),
                            height: xButtonSize + (isMobile ? 10 : 0),
                            pointIndex: i
                        };
                    }
                }
            });
        }

        function handleCanvasClick(e) {
            // Don't process click if we just finished dragging
            if (dragStartPos) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                // If mouse moved more than 5 pixels, it was a drag not a click
                const distance = Math.sqrt((x - dragStartPos.x) ** 2 + (y - dragStartPos.y) ** 2);
                if (distance > 5) {
                    dragStartPos = null;
                    return;
                }
                dragStartPos = null;
            }
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // Check if clicking on an X button to delete a segment
            if (isCalibrated) {
                for (let sectionIdx = 0; sectionIdx < sections.length; sectionIdx++) {
                    const section = sections[sectionIdx];
                    if (!section.deleteAreas) continue;
                    
                    for (let i = 0; i < section.deleteAreas.length; i++) {
                        const area = section.deleteAreas[i];
                        if (!area) continue;
                        
                        if (x >= area.x && x <= area.x + area.width &&
                            y >= area.y && y <= area.y + area.height) {
                            // Delete this segment
                            deleteSegment(sectionIdx, area.pointIndex);
                            return;
                        }
                    }
                }
                
                // Check if clicking near an existing point (to avoid accidental new points)
                const isMobile = forceMobileMode || window.innerWidth < 768;
                const detectionRadius = isMobile ? 80 : 12;
                
                for (let sectionIdx = 0; sectionIdx < sections.length; sectionIdx++) {
                    const section = sections[sectionIdx];
                    for (let pointIdx = 0; pointIdx < section.points.length; pointIdx++) {
                        const point = section.points[pointIdx];
                        const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                        
                        if (distance <= detectionRadius) {
                            // Clicking on existing point, don't add new one
                            return;
                        }
                    }
                }
            }

            if (!isCalibrated) {
                // Calibration mode
                calibrationPoints.push({ x, y });
                
                if (calibrationPoints.length === 2) {
                    const dx = calibrationPoints[1].x - calibrationPoints[0].x;
                    const dy = calibrationPoints[1].y - calibrationPoints[0].y;
                    const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                    const knownDistance = parseFloat(document.getElementById('knownDistance').value);
                    
                    calibrationFactor = knownDistance / pixelDistance;
                    isCalibrated = true;
                    
                    document.getElementById('calibrationStatus').className = 'status success';
                    document.getElementById('calibrationStatus').textContent = 
                        `‚úì Calibrated! 1 pixel = ${calibrationFactor.toFixed(4)} feet`;
                }
                
                drawCanvas();
            } else {
                // Measurement mode
                const currentSection = sections[currentSectionIndex];
                currentSection.points.push({ x, y });
                
                if (currentSection.points.length > 1) {
                    const lastIdx = currentSection.points.length - 1;
                    const p1 = currentSection.points[lastIdx - 1];
                    const p2 = currentSection.points[lastIdx];
                    
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                    const feetDistance = pixelDistance * calibrationFactor;
                    
                    currentSection.lengths.push(feetDistance);
                }
                
                saveState(); // Save state for undo/redo
                drawCanvas();
                updateMeasurementsList();
                updateEstimate();
            }
        }

        function deleteSegment(sectionIdx, pointIndex) {
            if (!confirm('Delete this segment? This will remove the point and line.')) return;
            
            saveState(); // Save state before deleting
            
            const section = sections[sectionIdx];
            
            // Remove the second point of the segment
            section.points.splice(pointIndex + 1, 1);
            
            // Completely rebuild lengths and delete areas for this section
            section.lengths = [];
            section.deleteAreas = [];
            
            // Recalculate all lengths from scratch
            for (let i = 0; i < section.points.length - 1; i++) {
                const p1 = section.points[i];
                const p2 = section.points[i + 1];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                const feetDistance = pixelDistance * calibrationFactor;
                section.lengths.push(feetDistance);
            }
            
            // Clear all delete areas for all sections
            sections.forEach(s => s.deleteAreas = []);
            
            // Force a complete redraw - clear canvas completely first
            if (canvas && ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                drawCanvas();
                ctx.restore();
            }
            
            updateMeasurementsList();
            updateEstimate();
        }

        function resetCalibration() {
            calibrationPoints = [];
            isCalibrated = false;
            document.getElementById('calibrationStatus').className = 'status info';
            document.getElementById('calibrationStatus').textContent = 
                'Click two points on a known distance (door, window, etc.)';
            drawCanvas();
        }

        function startNewSection() {
            if (!isCalibrated) {
                alert('Please calibrate first!');
                return;
            }
            
            // Create a new section
            const nextIndex = sections.length;
            const colorIndex = nextIndex % sectionColors.length; // Cycle through colors
            
            sections.push({
                color: sectionColors[colorIndex],
                name: `Section ${nextIndex + 1}`,
                points: [],
                lengths: [],
                deleteAreas: []
            });
            
            currentSectionIndex = nextIndex;
            
            updateMeasurementsList();
            alert(`Started Section ${nextIndex + 1}! Click on the image to add measurement points.`);
        }

        function saveState() {
            // Save current state to history
            const state = {
                sections: sections.map(section => ({
                    color: section.color,
                    name: section.name,
                    points: JSON.parse(JSON.stringify(section.points)),
                    lengths: JSON.parse(JSON.stringify(section.lengths))
                })),
                currentSectionIndex: currentSectionIndex
            };
            
            // Remove any states after current index (if we undid and then made changes)
            history = history.slice(0, historyIndex + 1);
            
            // Add new state
            history.push(state);
            historyIndex++;
            
            // Limit history to 50 states
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }
        }

        function restoreState(state) {
            sections = state.sections.map(section => ({
                color: section.color,
                name: section.name,
                points: JSON.parse(JSON.stringify(section.points)),
                lengths: JSON.parse(JSON.stringify(section.lengths)),
                deleteAreas: []
            }));
            currentSectionIndex = state.currentSectionIndex;
            
            drawCanvas();
            updateMeasurementsList();
            updateEstimate();
        }

        function undoPoint() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(history[historyIndex]);
            } else {
                alert('Nothing to undo!');
            }
        }

        function redoPoint() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState(history[historyIndex]);
            } else {
                alert('Nothing to redo!');
            }
        }

        function clearAll() {
            if (confirm('Clear all measurements?')) {
                sections.forEach(section => {
                    section.points = [];
                    section.lengths = [];
                    section.deleteAreas = [];
                });
                currentSectionIndex = 0;
                
                // Force complete canvas clear and redraw
                if (canvas && ctx && image) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(image, 0, 0);
                    
                    // Redraw calibration if it exists
                    if (calibrationPoints.length === 2) {
                        ctx.strokeStyle = '#0066ff';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(calibrationPoints[0].x, calibrationPoints[0].y);
                        ctx.lineTo(calibrationPoints[1].x, calibrationPoints[1].y);
                        ctx.stroke();
                        
                        calibrationPoints.forEach(point => {
                            ctx.fillStyle = '#0066ff';
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                            ctx.fill();
                        });
                    }
                }
                
                updateMeasurementsList();
                updateEstimate();
            }
        }

        function zoomIn() {
            zoomLevel += 0.2;
            canvas.style.transform = `scale(${zoomLevel})`;
            canvas.style.transformOrigin = 'top left';
        }

        function zoomOut() {
            zoomLevel = Math.max(0.5, zoomLevel - 0.2);
            canvas.style.transform = `scale(${zoomLevel})`;
            canvas.style.transformOrigin = 'top left';
        }

        function updateMeasurementsList() {
            const list = document.getElementById('measurementsList');
            list.innerHTML = '';
            
            // Update legend dynamically
            updateLegend();
            
            sections.forEach((section, idx) => {
                if (section.points.length > 0) {
                    const total = section.lengths.reduce((sum, len) => sum + len, 0);
                    const colorClass = section.color.replace('#', '');
                    
                    const div = document.createElement('div');
                    div.className = `measurement-item ${getColorName(section.color)}`;
                    div.innerHTML = `
                        <div>
                            <strong>${section.name}</strong>: ${section.points.length} points
                        </div>
                        <div style="font-weight: bold;">${total.toFixed(1)} ft</div>
                    `;
                    list.appendChild(div);
                }
            });
        }

        function updateLegend() {
            const legend = document.getElementById('sectionLegend');
            if (!legend) return;
            
            legend.innerHTML = '';
            
            sections.forEach((section, idx) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${section.color};"></div>
                    <span>${section.name}</span>
                `;
                legend.appendChild(item);
            });
        }

        function getColorName(hex) {
            const colors = {
                '#ff0000': 'red',
                '#ff8800': 'orange',
                '#00cc00': 'green',
                '#0066ff': 'blue',
                '#cc00cc': 'purple',
                '#ff66cc': 'pink'
            };
            return colors[hex] || 'red';
        }

        function addManualMeasurement() {
            const id = Date.now();
            manualMeasurements.push({ id, label: '', length: 0 });
            renderManualMeasurements();
        }

        function renderManualMeasurements() {
            const container = document.getElementById('manualMeasurements');
            container.innerHTML = '';
            
            manualMeasurements.forEach(item => {
                const div = document.createElement('div');
                div.className = 'manual-measurement';
                div.innerHTML = `
                    <input type="text" placeholder="Label (e.g., 'Back wall')" 
                           value="${item.label}" 
                           onchange="updateManualLabel(${item.id}, this.value)">
                    <input type="number" placeholder="Length in feet" 
                           value="${item.length}" step="0.5" min="0"
                           onchange="updateManualLength(${item.id}, this.value)">
                    <button class="remove-btn" onclick="removeManualMeasurement(${item.id})">Remove</button>
                `;
                container.appendChild(div);
            });
        }

        function updateManualLabel(id, value) {
            const item = manualMeasurements.find(m => m.id === id);
            if (item) {
                item.label = value;
                updateEstimate();
            }
        }

        function updateManualLength(id, value) {
            const item = manualMeasurements.find(m => m.id === id);
            if (item) {
                item.length = parseFloat(value) || 0;
                updateEstimate();
            }
        }

        function removeManualMeasurement(id) {
            manualMeasurements = manualMeasurements.filter(m => m.id !== id);
            renderManualMeasurements();
            updateEstimate();
        }

        function addWreath() {
            const id = Date.now();
            wreaths.push({ id, size: '24', quantity: 1, price: 25 });
            renderWreaths();
        }

        function renderWreaths() {
            const container = document.getElementById('wreathsList');
            container.innerHTML = '';
            
            wreaths.forEach(wreath => {
                const div = document.createElement('div');
                div.className = 'wreath-entry';
                div.innerHTML = `
                    <label>Size:</label>
                    <select onchange="updateWreathSize(${wreath.id}, this.value)">
                        <option value="24" ${wreath.size === '24' ? 'selected' : ''}>24 inch</option>
                        <option value="36" ${wreath.size === '36' ? 'selected' : ''}>36 inch</option>
                        <option value="48" ${wreath.size === '48' ? 'selected' : ''}>48 inch</option>
                        <option value="60" ${wreath.size === '60' ? 'selected' : ''}>60 inch</option>
                        <option value="72" ${wreath.size === '72' ? 'selected' : ''}>72 inch</option>
                    </select>
                    <label>Quantity:</label>
                    <input type="number" value="${wreath.quantity}" min="1" 
                           onchange="updateWreathQuantity(${wreath.id}, this.value)">
                    <label>Price Each: $</label>
                    <input type="number" value="${wreath.price}" step="1" min="0"
                           onchange="updateWreathPrice(${wreath.id}, this.value)">
                    <button class="remove-btn" onclick="removeWreath(${wreath.id})">Remove</button>
                `;
                container.appendChild(div);
            });
            
            updateEstimate();
        }

        function updateWreathSize(id, size) {
            const wreath = wreaths.find(w => w.id === id);
            if (wreath) {
                wreath.size = size;
                updateEstimate();
            }
        }

        function updateWreathQuantity(id, quantity) {
            const wreath = wreaths.find(w => w.id === id);
            if (wreath) {
                wreath.quantity = parseInt(quantity) || 1;
                updateEstimate();
            }
        }

        function updateWreathPrice(id, price) {
            const wreath = wreaths.find(w => w.id === id);
            if (wreath) {
                wreath.price = parseFloat(price) || 0;
                updateEstimate();
            }
        }

        function removeWreath(id) {
            wreaths = wreaths.filter(w => w.id !== id);
            renderWreaths();
        }

        function updateEstimate() {
            // Calculate roofline total
            let rooflineFootage = 0;
            sections.forEach(section => {
                rooflineFootage += section.lengths.reduce((sum, len) => sum + len, 0);
            });
            
            manualMeasurements.forEach(item => {
                rooflineFootage += item.length;
            });
            
            const pricePerFoot = parseFloat(document.getElementById('pricePerFoot').value) || 0;
            const rooflineTotal = rooflineFootage * pricePerFoot;
            
            document.getElementById('rooflineDetails').textContent = `${rooflineFootage.toFixed(1)} ft √ó $${pricePerFoot}/ft`;
            document.getElementById('rooflineTotal').textContent = `$${rooflineTotal.toFixed(2)}`;

            // Calculate wreath total
            let wreathTotal = 0;
            let wreathDetailsText = [];
            wreaths.forEach(wreath => {
                const subtotal = wreath.quantity * wreath.price;
                wreathTotal += subtotal;
                wreathDetailsText.push(`${wreath.quantity} √ó ${wreath.size}" @ $${wreath.price} each`);
            });
            
            document.getElementById('wreathDetails').textContent = 
                wreathDetailsText.length > 0 ? wreathDetailsText.join(', ') : 'None';
            document.getElementById('wreathTotal').textContent = `$${wreathTotal.toFixed(2)}`;

            // Calculate column wraps
            const columnCount = parseInt(document.getElementById('columnCount').value) || 0;
            const columnPrice = parseFloat(document.getElementById('columnPrice').value) || 0;
            const columnTotal = columnCount * columnPrice;
            
            document.getElementById('columnDetails').textContent = `${columnCount} wraps`;
            document.getElementById('columnTotal').textContent = `$${columnTotal.toFixed(2)}`;

            // Calculate shrub wraps
            const shrubCount = parseInt(document.getElementById('shrubCount').value) || 0;
            const shrubPrice = parseFloat(document.getElementById('shrubPrice').value) || 0;
            const shrubTotal = shrubCount * shrubPrice;
            
            document.getElementById('shrubDetails').textContent = `${shrubCount} wraps`;
            document.getElementById('shrubTotal').textContent = `$${shrubTotal.toFixed(2)}`;

            // Grand total
            const grandTotal = rooflineTotal + wreathTotal + columnTotal + shrubTotal;
            document.getElementById('grandTotal').textContent = `$${grandTotal.toFixed(2)}`;
        }

        function exportSinglePDF() {
            exportTiersPDF(false);
        }

        function exportAllTiersPDF() {
            exportTiersPDF(true);
        }

        function exportTiersPDF(exportAll) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            const customerName = document.getElementById('customerName').value || 'Customer';
            const customerAddress = document.getElementById('customerAddress').value || '';
            
            // Get export options
            const showMeasurements = document.getElementById('exportShowMeasurements').checked;
            const showPricePerFoot = document.getElementById('exportShowPricePerFoot').checked;
            const showWreathPrices = document.getElementById('exportShowWreathPrices').checked;
            const showWrapPrices = document.getElementById('exportShowWrapPrices').checked;
            
            let logoData = savedLogoData;
            
            // If no saved logo, check if one was just uploaded
            const logoFile = document.getElementById('logoUpload').files[0];
            if (!logoData && logoFile) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    logoData = e.target.result;
                    generatePDF();
                };
                reader.readAsDataURL(logoFile);
            } else {
                generatePDF();
            }
            
            function generatePDF() {
                const tiersToExport = exportAll ? [1, 2, 3] : [1];
                
                tiersToExport.forEach((tierNum, index) => {
                    if (index > 0) {
                        doc.addPage();
                    }
                    generateTierPage(doc, tierNum);
                });
                
                // Save
                const filename = exportAll 
                    ? `${customerName.replace(/\s+/g, '_')}_ChristmasLights_AllTiers.pdf`
                    : `${customerName.replace(/\s+/g, '_')}_ChristmasLights_Basic.pdf`;
                doc.save(filename);
            }
            
            function generateTierPage(doc, tierNum) {
                const tierData = tiers[tierNum];
                const customerName = document.getElementById('customerName').value || 'Customer';
                const customerAddress = document.getElementById('customerAddress').value || '';
                const pricePerFoot = parseFloat(document.getElementById('pricePerFoot').value) || 0;
                
                let yPos = 20;
                
                // Title
                doc.setFontSize(22);
                doc.setTextColor(44, 95, 45);
                doc.text('Christmas Light Installation Quote', 105, 20, { align: 'center' });
                
                // Tier name subtitle
                doc.setFontSize(16);
                doc.setTextColor(0, 102, 255);
                doc.text(tierData.name, 105, 30, { align: 'center' });
                yPos = 35;
                
                // Customer info
                doc.setFontSize(12);
                doc.setTextColor(0, 0, 0);
                doc.text(`Customer: ${customerName}`, 20, yPos + 15);
                doc.text(`Address: ${customerAddress}`, 20, yPos + 23);
                doc.text(`Date: ${new Date().toLocaleDateString()}`, 20, yPos + 31);
                
                // Line
                doc.setDrawColor(44, 95, 45);
                doc.setLineWidth(0.5);
                doc.line(20, yPos + 37, 190, yPos + 37);
                
                yPos = yPos + 50;
                
                // Add photo with tier's measurements (NO calibration line)
                if (canvas && image) {
                    // Create temp canvas with this tier's sections
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Draw base image
                    tempCtx.drawImage(image, 0, 0);
                    
                    const showMeasurements = document.getElementById('exportShowMeasurements').checked;
                    const isMobile = forceMobileMode || window.innerWidth < 768;
                    
                    // Draw this tier's sections
                    tierData.sections.forEach((section) => {
                        if (section.points.length === 0) return;
                        
                        const measurePointSize = isMobile ? 50 : 8;
                        const pointNumberFontSize = isMobile ? 32 : 12;
                        const lineWidth = isMobile ? 12 : 3;
                        
                        tempCtx.strokeStyle = section.color;
                        tempCtx.lineWidth = lineWidth;
                        
                        // Draw lines
                        for (let i = 0; i < section.points.length - 1; i++) {
                            if (section.points[i] && section.points[i + 1]) {
                                tempCtx.beginPath();
                                tempCtx.moveTo(section.points[i].x, section.points[i].y);
                                tempCtx.lineTo(section.points[i + 1].x, section.points[i + 1].y);
                                tempCtx.stroke();
                            }
                        }
                        
                        // Only draw points and numbers if measurements are shown
                        if (showMeasurements) {
                            // Draw points with numbers
                            section.points.forEach((point, idx) => {
                                if (point) {
                                    tempCtx.fillStyle = section.color;
                                    tempCtx.beginPath();
                                    tempCtx.arc(point.x, point.y, measurePointSize, 0, Math.PI * 2);
                                    tempCtx.fill();
                                    
                                    tempCtx.strokeStyle = 'white';
                                    tempCtx.lineWidth = 2;
                                    tempCtx.stroke();
                                    
                                    tempCtx.fillStyle = 'white';
                                    tempCtx.font = `bold ${pointNumberFontSize}px Arial`;
                                    tempCtx.textAlign = 'center';
                                    tempCtx.textBaseline = 'middle';
                                    tempCtx.fillText((idx + 1).toString(), point.x, point.y);
                                }
                            });
                        }
                        
                        // Draw measurement labels if enabled
                        if (showMeasurements) {
                            const labelFontSize = isMobile ? 14 : 11;
                            const boxHeight = isMobile ? 24 : 16;
                            
                            for (let i = 0; i < section.points.length - 1; i++) {
                                if (section.lengths[i] && section.points[i] && section.points[i + 1]) {
                                    const midX = (section.points[i].x + section.points[i + 1].x) / 2;
                                    const midY = (section.points[i].y + section.points[i + 1].y) / 2;
                                    
                                    const labelText = section.lengths[i].toFixed(1) + ' ft';
                                    tempCtx.font = `bold ${labelFontSize}px Arial`;
                                    const textWidth = tempCtx.measureText(labelText).width;
                                    
                                    const padding = isMobile ? 6 : 4;
                                    const boxWidth = textWidth + padding * 2;
                                    
                                    tempCtx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                                    tempCtx.beginPath();
                                    tempCtx.roundRect(midX - boxWidth/2, midY - boxHeight/2, boxWidth, boxHeight, 3);
                                    tempCtx.fill();
                                    
                                    tempCtx.fillStyle = '#333';
                                    tempCtx.textAlign = 'center';
                                    tempCtx.textBaseline = 'middle';
                                    tempCtx.fillText(labelText, midX, midY);
                                }
                            }
                        }
                    });
                    
                    const photoImage = tempCanvas.toDataURL('image/jpeg', 0.7);
                    
                    // Add to PDF - adjust size to fit on same page as pricing
                    const maxWidth = 170;
                    const maxHeight = 80; // Reduced from 100 to fit pricing below
                    let imgWidth = canvas.width;
                    let imgHeight = canvas.height;
                    
                    const ratio = Math.min(maxWidth / imgWidth, maxHeight / imgHeight);
                    imgWidth = imgWidth * ratio;
                    imgHeight = imgHeight * ratio;
                    
                    doc.setFontSize(14);
                    doc.setTextColor(44, 95, 45);
                    doc.text('Roof Photo:', 20, yPos);
                    yPos += 8;
                    
                    doc.addImage(photoImage, 'JPEG', 20, yPos, imgWidth, imgHeight);
                    yPos += imgHeight + 15;
                }
                
                // Calculate totals from tier data
                const rooflineFootage = tierData.sections.reduce((sum, s) => 
                    sum + s.lengths.reduce((s2, l) => s2 + l, 0), 0) + 
                    tierData.manualMeasurements.reduce((sum, m) => sum + m.length, 0);
                const rooflineTotal = rooflineFootage * pricePerFoot;
                
                const wreathTotal = tierData.wreaths.reduce((sum, w) => sum + (w.quantity * w.price), 0);
                const columnTotal = tierData.columnCount * tierData.columnPrice;
                const shrubTotal = tierData.shrubCount * tierData.shrubPrice;
                
                const showPricePerFoot = document.getElementById('exportShowPricePerFoot').checked;
                const showWreathPrices = document.getElementById('exportShowWreathPrices').checked;
                const showWrapPrices = document.getElementById('exportShowWrapPrices').checked;
                
                // Roofline
                doc.setFontSize(14);
                doc.text('Roofline Lights:', 20, yPos);
                
                if (showMeasurements && showPricePerFoot) {
                    doc.text(`${rooflineFootage.toFixed(1)} ft √ó $${pricePerFoot}/ft`, 80, yPos);
                } else if (showMeasurements) {
                    doc.text(`${rooflineFootage.toFixed(1)} ft`, 80, yPos);
                } else if (showPricePerFoot) {
                    doc.text(`$${pricePerFoot}/ft`, 80, yPos);
                }
                
                doc.text(`$${rooflineTotal.toFixed(2)}`, 160, yPos, { align: 'right' });
                yPos += 10;
                
                // Wreaths
                if (tierData.wreaths.length > 0) {
                    doc.text('Wreaths:', 20, yPos);
                    yPos += 8;
                    
                    if (showWreathPrices) {
                        tierData.wreaths.forEach(wreath => {
                            doc.setFontSize(11);
                            const subtotal = wreath.quantity * wreath.price;
                            doc.text(`  ${wreath.quantity} √ó ${wreath.size}" @ $${wreath.price}`, 25, yPos);
                            doc.text(`$${subtotal.toFixed(2)}`, 160, yPos, { align: 'right' });
                            yPos += 7;
                        });
                    } else {
                        doc.setFontSize(11);
                        const totalWreaths = tierData.wreaths.reduce((sum, w) => sum + w.quantity, 0);
                        doc.text(`  ${totalWreaths} wreaths (various sizes)`, 25, yPos);
                        doc.text(`$${wreathTotal.toFixed(2)}`, 160, yPos, { align: 'right' });
                        yPos += 7;
                    }
                    doc.setFontSize(14);
                    yPos += 3;
                }
                
                // Columns
                if (tierData.columnCount > 0) {
                    doc.text('Column Wraps:', 20, yPos);
                    if (showWrapPrices) {
                        doc.text(`${tierData.columnCount} √ó $${tierData.columnPrice}`, 80, yPos);
                    }
                    doc.text(`$${columnTotal.toFixed(2)}`, 160, yPos, { align: 'right' });
                    yPos += 10;
                }
                
                // Shrubs
                if (tierData.shrubCount > 0) {
                    doc.text('Shrub Wraps:', 20, yPos);
                    if (showWrapPrices) {
                        doc.text(`${tierData.shrubCount} √ó $${tierData.shrubPrice}`, 80, yPos);
                    }
                    doc.text(`$${shrubTotal.toFixed(2)}`, 160, yPos, { align: 'right' });
                    yPos += 10;
                }
                
                // Total
                yPos += 5;
                doc.setDrawColor(44, 95, 45);
                doc.line(20, yPos, 190, yPos);
                yPos += 10;
                
                doc.setFontSize(18);
                doc.setTextColor(44, 95, 45);
                const grandTotal = rooflineTotal + wreathTotal + columnTotal + shrubTotal;
                doc.text('TOTAL:', 20, yPos);
                doc.text(`$${grandTotal.toFixed(2)}`, 190, yPos, { align: 'right' });
                
                // Add logo at bottom if available
                if (logoData) {
                    const logoImg = new Image();
                    logoImg.src = logoData;
                    const logoMaxWidth = 60;  // Reduced from 80
                    const logoMaxHeight = 45; // Reduced from 60
                    let logoWidth = logoImg.width;
                    let logoHeight = logoImg.height;
                    const logoRatio = Math.min(logoMaxWidth / logoWidth, logoMaxHeight / logoHeight);
                    logoWidth = logoWidth * logoRatio;
                    logoHeight = logoHeight * logoRatio;
                    
                    const logoX = (210 - logoWidth) / 2;
                    // Position logo after total with some spacing, but ensure it fits on page
                    const logoY = Math.min(yPos + 20, 260); // Max Y=260 to stay on page (A4 height ~297mm)
                    
                    doc.addImage(logoData, 'JPEG', logoX, logoY, logoWidth, logoHeight);
                }
            }
        }

        // Project Save/Load Functions
        // Project Save/Load Functions
        function saveProject() {
            const customerName = document.getElementById('customerName').value || 'Untitled';
            
            // Create project data object
            const projectData = {
                version: '1.0',
                customerName: document.getElementById('customerName').value,
                customerAddress: document.getElementById('customerAddress').value,
                calibrationFactor: calibrationFactor,
                calibrationPoints: calibrationPoints,
                isCalibrated: isCalibrated,
                knownDistance: document.getElementById('knownDistance').value,
                sections: sections.map(section => ({
                    color: section.color,
                    name: section.name,
                    points: section.points,
                    lengths: section.lengths
                })),
                currentSectionIndex: currentSectionIndex,
                manualMeasurements: manualMeasurements,
                wreaths: wreaths,
                columnCount: document.getElementById('columnCount').value,
                columnPrice: document.getElementById('columnPrice').value,
                shrubCount: document.getElementById('shrubCount').value,
                shrubPrice: document.getElementById('shrubPrice').value,
                pricePerFoot: document.getElementById('pricePerFoot').value,
                imageData: originalImageData, // Save original image, not canvas with drawings
                timestamp: new Date().toISOString()
            };

            // Convert to JSON and create download
            const jsonString = JSON.stringify(projectData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${customerName.replace(/\s+/g, '_')}_Project.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('Project saved! You can load this file later to continue editing.');
        }

        function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const projectData = JSON.parse(event.target.result);
                        
                        // Validate project data
                        if (!projectData.version) {
                            alert('Invalid project file!');
                            return;
                        }
                        
                        // Restore customer information
                        document.getElementById('customerName').value = projectData.customerName || '';
                        document.getElementById('customerAddress').value = projectData.customerAddress || '';
                        
                        // Restore calibration
                        calibrationFactor = projectData.calibrationFactor;
                        calibrationPoints = projectData.calibrationPoints || [];
                        isCalibrated = projectData.isCalibrated || false;
                        document.getElementById('knownDistance').value = projectData.knownDistance || 8;
                        
                        if (isCalibrated) {
                            document.getElementById('calibrationStatus').className = 'status success';
                            document.getElementById('calibrationStatus').textContent = 
                                `‚úì Calibrated! 1 pixel = ${calibrationFactor.toFixed(4)} feet`;
                        }
                        
                        // Restore sections - make sure to clear deleteAreas
                        sections = projectData.sections.map(section => ({
                            color: section.color,
                            name: section.name,
                            points: section.points || [],
                            lengths: section.lengths || [],
                            deleteAreas: [] // Clear this to force recalculation
                        }));
                        currentSectionIndex = projectData.currentSectionIndex || 0;
                        
                        // Restore manual measurements
                        manualMeasurements = projectData.manualMeasurements || [];
                        renderManualMeasurements();
                        
                        // Restore wreaths
                        wreaths = projectData.wreaths || [];
                        renderWreaths();
                        
                        // Restore pricing
                        document.getElementById('columnCount').value = projectData.columnCount || 0;
                        document.getElementById('columnPrice').value = projectData.columnPrice || 40;
                        document.getElementById('shrubCount').value = projectData.shrubCount || 0;
                        document.getElementById('shrubPrice').value = projectData.shrubPrice || 30;
                        document.getElementById('pricePerFoot').value = projectData.pricePerFoot || 8;
                        
                        // Restore image
                        if (projectData.imageData) {
                            originalImageData = projectData.imageData; // Restore original image data
                            image = new Image();
                            image.onload = function() {
                                // Setup canvas with event listeners
                                canvas = document.getElementById('measureCanvas');
                                ctx = canvas.getContext('2d');
                                
                                canvas.width = image.width;
                                canvas.height = image.height;
                                
                                // CRITICAL: Clear the entire canvas first
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                
                                // Remove old event listeners if they exist
                                const newCanvas = canvas.cloneNode(true);
                                canvas.parentNode.replaceChild(newCanvas, canvas);
                                canvas = newCanvas;
                                ctx = canvas.getContext('2d');
                                
                                // Clear again after cloning
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                
                                // Add event listeners
                                canvas.addEventListener('mousedown', handleMouseDown);
                                canvas.addEventListener('mousemove', handleMouseMove);
                                canvas.addEventListener('mouseup', handleMouseUp);
                                canvas.addEventListener('click', handleCanvasClick);
                                
                                // Touch events for mobile
                                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
                                
                                document.getElementById('canvasSection').style.display = 'block';
                                document.getElementById('instructionsCollapsible').style.display = 'block';
                                
                                // Draw everything fresh
                                drawCanvas();
                                updateMeasurementsList();
                                updateEstimate();
                            };
                            image.src = originalImageData;
                        } else {
                            // No image data, but still update UI
                            updateMeasurementsList();
                            updateEstimate();
                        }
                        
                        alert('Project loaded successfully! You can now edit measurements, delete points, or update pricing.');
                        
                    } catch (error) {
                        alert('Error loading project file: ' + error.message);
                        console.error('Load error:', error);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }
    </script>
</body>
</html>
