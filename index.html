<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Christmas Light Estimation Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-text-size-adjust: 100%;
            -moz-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            width: 100%;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            overflow: hidden;
        }

        h1 {
            text-align: center;
            color: #2c5f2d;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .customer-info {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .input-group input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
        }

        .input-group input:focus {
            outline: none;
            border-color: #2c5f2d;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            margin-bottom: 30px;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e0e0e0;
        }

        .section h2 {
            color: #2c5f2d;
            margin-bottom: 15px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .upload-area {
            border: 3px dashed #2c5f2d;
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            background: #f0f7f0;
            border-color: #1a3a1b;
        }

        .upload-area input {
            display: none;
        }

        .canvas-container {
            position: relative;
            overflow: auto;
            max-height: 600px;
            border: 2px solid #ddd;
            border-radius: 10px;
            background: #fff;
            width: 100%;
            max-width: 100%;
        }

        #measureCanvas {
            cursor: crosshair;
            display: block;
            max-width: 100%;
            height: auto;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .btn-primary {
            background: #2c5f2d;
            color: white;
        }

        .btn-primary:hover {
            background: #1a3a1b;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn-warning {
            background: #ffc107;
            color: #333;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .calibration-input {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .calibration-input input {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            width: 100px;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-weight: 600;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
        }

        .measurements-list {
            margin-top: 15px;
        }

        .measurement-item {
            background: white;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 4px solid;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .measurement-item.red { border-left-color: #ff0000; }
        .measurement-item.orange { border-left-color: #ff8800; }
        .measurement-item.green { border-left-color: #00cc00; }
        .measurement-item.blue { border-left-color: #0066ff; }
        .measurement-item.purple { border-left-color: #cc00cc; }
        .measurement-item.pink { border-left-color: #ff66cc; }

        .manual-measurement {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border: 2px solid #cc00cc;
        }

        .manual-measurement input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
        }

        .estimate-box {
            background: white;
            border: 3px solid #2c5f2d;
            border-radius: 10px;
            padding: 20px;
            position: sticky;
            top: 20px;
        }

        .estimate-box h2 {
            color: #2c5f2d;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.8em;
        }

        .estimate-item {
            padding: 12px;
            margin: 8px 0;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .estimate-item label {
            font-weight: 600;
            color: #333;
        }

        .estimate-item .value {
            font-weight: bold;
            color: #2c5f2d;
            font-size: 1.1em;
        }

        .estimate-total {
            margin-top: 20px;
            padding: 20px;
            background: #2c5f2d;
            color: white;
            border-radius: 10px;
            text-align: center;
        }

        .estimate-total h3 {
            font-size: 1.3em;
            margin-bottom: 10px;
        }

        .estimate-total .total-value {
            font-size: 2.5em;
            font-weight: bold;
        }

        .pricing-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .pricing-input input {
            width: 80px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            text-align: right;
        }

        .wreath-entry {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border: 2px solid #2c5f2d;
        }

        .wreath-entry input, .wreath-entry select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
        }

        .remove-btn {
            background: #dc3545;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 10;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #2c5f2d;
            color: white;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .zoom-btn:hover {
            background: #1a3a1b;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 30px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid #333;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .estimate-box {
                position: relative;
                top: 0;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.8em;
            }

            .subtitle {
                font-size: 1em;
            }

            .customer-info {
                grid-template-columns: 1fr;
                gap: 10px;
                padding: 15px;
            }

            .controls {
                flex-direction: column;
            }

            .controls button {
                width: 100%;
                margin-bottom: 5px;
            }

            .pricing-input {
                flex-wrap: wrap;
                gap: 5px;
            }

            .pricing-input input {
                width: 60px;
            }

            .legend {
                gap: 8px;
            }

            .legend-item {
                font-size: 0.9em;
            }

            .section {
                padding: 15px;
            }

            .section h2 {
                font-size: 1.3em;
            }

            .canvas-container {
                max-height: 400px;
                overflow: auto;
                -webkit-overflow-scrolling: touch;
            }

            #measureCanvas {
                max-width: 100%;
                height: auto;
                width: 100%;
                object-fit: contain;
            }

            .section {
                overflow: hidden;
            }

            .zoom-btn {
                width: 50px;
                height: 50px;
                font-size: 1.8em;
            }

            .estimate-box {
                padding: 15px;
                margin-bottom: 20px;
            }

            .estimate-box h2 {
                font-size: 1.5em;
            }

            .estimate-total .total-value {
                font-size: 2em;
            }

            button {
                padding: 14px 20px;
                font-size: 1em;
                min-height: 44px; /* Touch-friendly */
            }

            .input-group input {
                font-size: 16px; /* Prevent zoom on iOS */
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.5em;
            }

            .subtitle {
                font-size: 0.9em;
            }

            .section h2 {
                font-size: 1.2em;
            }

            .estimate-total .total-value {
                font-size: 1.8em;
            }

            .wreath-entry input, 
            .wreath-entry select,
            .manual-measurement input {
                font-size: 16px; /* Prevent zoom on iOS */
            }

            .zoom-controls {
                top: 5px;
                right: 5px;
            }

            .zoom-btn {
                width: 45px;
                height: 45px;
            }
        }

        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            /* This targets touch devices */
            button {
                min-height: 48px;
                padding: 16px 24px;
            }

            .measurement-item {
                padding: 12px;
            }

            .remove-btn {
                min-height: 40px;
                padding: 8px 12px;
            }

            #measureCanvas {
                touch-action: none; /* Prevent default touch behaviors */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÑ Christmas Light Estimation Tool üéÑ</h1>
        <p class="subtitle">Professional Roof Measuring & Quote Generator</p>

        <!-- Load Project Button at Top -->
        <div style="text-align: center; margin-bottom: 20px;">
            <button class="btn-primary" onclick="loadProject()" style="background: #17a2b8; font-size: 1.1em; padding: 15px 30px;">
                üìÇ Load Saved Project
            </button>
            <p style="color: #666; margin-top: 8px; font-size: 0.9em;">Load a previous project to view or edit measurements</p>
        </div>

        <!-- Customer Information -->
        <div class="customer-info">
            <div class="input-group">
                <label>Customer Name:</label>
                <input type="text" id="customerName" placeholder="Enter customer name">
            </div>
            <div class="input-group">
                <label>Address:</label>
                <input type="text" id="customerAddress" placeholder="Enter property address">
            </div>
        </div>

        <div class="main-layout">
            <!-- Left Panel -->
            <div class="left-panel">
                <!-- Image Upload Section -->
                <div class="section">
                    <h2>üì∑ Step 1: Upload Roof Photo</h2>
                    <div class="upload-area" onclick="document.getElementById('imageUpload').click()">
                        <input type="file" id="imageUpload" accept="image/*">
                        <p style="font-size: 1.2em; color: #2c5f2d; font-weight: 600;">Click to upload roof image</p>
                        <p style="color: #666; margin-top: 10px;">Supports JPG, PNG, WEBP</p>
                    </div>
                </div>

                <!-- Canvas Section -->
                <div class="section" id="canvasSection" style="display: none;">
                    <h2>üìè Calibrate & Measure</h2>
                    
                    <!-- Collapsible Instructions -->
                    <div id="instructionsCollapsible" style="display: none; margin-bottom: 15px;">
                        <button onclick="toggleInstructions()" style="width: 100%; text-align: left; background: #e8f5e9; border: 2px solid #4caf50; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 600; color: #2c5f2d; display: flex; justify-content: space-between; align-items: center;">
                            <span>‚ÑπÔ∏è How to Add Measurement Points</span>
                            <span id="instructionsToggle">‚ñº</span>
                        </button>
                        <div id="instructionsContent" style="display: none; background: #f0f8f0; border: 2px solid #4caf50; border-top: none; padding: 15px; border-radius: 0 0 8px 8px; line-height: 1.8;">
                            <p style="margin-bottom: 10px;"><strong>How to measure your roofline:</strong></p>
                            <ol style="margin-left: 20px; margin-bottom: 15px;">
                                <li>Click along the roofline where you want lights installed</li>
                                <li>Each click adds a numbered point</li>
                                <li>Points automatically connect with lines</li>
                                <li>Distance in feet shows on each segment</li>
                            </ol>
                            
                            <p style="margin-bottom: 10px;"><strong>Tips:</strong></p>
                            <ul style="margin-left: 20px; margin-bottom: 15px;">
                                <li><strong>Move a point:</strong> Click and drag any numbered point</li>
                                <li><strong>Delete a segment:</strong> Click the ‚ùå next to the footage label</li>
                                <li><strong>New section:</strong> Click "Start New Section" for different roof levels</li>
                                <li><strong>Zoom:</strong> Use + and - buttons to zoom in/out</li>
                                <li><strong>Undo/Redo:</strong> Made a mistake? Use the undo/redo buttons</li>
                            </ul>
                            
                            <p style="color: #2c5f2d; font-weight: bold;">Start clicking on your roof to begin measuring! üéØ</p>
                        </div>
                    </div>
                    
                    <div id="calibrationStatus" class="status info">
                        Click two points on a known distance (door, window, etc.)
                    </div>

                    <div class="calibration-input">
                        <label>Known Distance:</label>
                        <input type="number" id="knownDistance" value="8" step="0.5" min="0">
                        <span>feet</span>
                        <button class="btn-warning" onclick="resetCalibration()">Reset Calibration</button>
                    </div>

                    <div class="canvas-container" style="margin-top: 15px; position: relative;">
                        <div class="zoom-controls">
                            <button class="zoom-btn" onclick="zoomIn()">+</button>
                            <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
                        </div>
                        <canvas id="measureCanvas"></canvas>
                    </div>

                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff0000;"></div>
                            <span>Section 1</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff8800;"></div>
                            <span>Section 2</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #00cc00;"></div>
                            <span>Section 3</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #0066ff;"></div>
                            <span>Section 4</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #cc00cc;"></div>
                            <span>Section 5</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff66cc;"></div>
                            <span>Section 6</span>
                        </div>
                    </div>

                    <div class="controls">
                        <button class="btn-primary" onclick="startNewSection()">Start New Section</button>
                        <button class="btn-warning" onclick="undoPoint()">‚Ü∂ Undo Point</button>
                        <button class="btn-warning" onclick="redoPoint()">‚Ü∑ Redo Point</button>
                        <button class="btn-secondary" onclick="clearAll()">Clear All</button>
                        <button class="btn-primary" onclick="saveProject()" style="background: #17a2b8;">üíæ Save Project</button>
                    </div>

                    <div class="measurements-list" id="measurementsList"></div>
                </div>

                <!-- Manual Measurements -->
                <div class="section">
                    <h2>‚úçÔ∏è Manual Measurements</h2>
                    <p style="color: #666; margin-bottom: 10px;">Add unmeasurable sides (back walls, hidden areas, etc.)</p>
                    <div id="manualMeasurements"></div>
                    <button class="btn-primary" onclick="addManualMeasurement()">+ Add Manual Entry</button>
                </div>

                <!-- Wreaths Section -->
                <div class="section">
                    <h2>üåø Wreaths</h2>
                    <div id="wreathsList"></div>
                    <button class="btn-primary" onclick="addWreath()">+ Add Wreath</button>
                </div>

                <!-- Column & Shrub Wraps -->
                <div class="section">
                    <h2>üå≤ Column & Shrub Wraps</h2>
                    <div class="pricing-input" style="margin-bottom: 15px;">
                        <label>Column Wraps:</label>
                        <input type="number" id="columnCount" value="0" min="0" onchange="updateEstimate()">
                        <span>@ $</span>
                        <input type="number" id="columnPrice" value="40" step="1" min="0" onchange="updateEstimate()">
                        <span>per strand</span>
                    </div>
                    <div class="pricing-input">
                        <label>Shrub Wraps:</label>
                        <input type="number" id="shrubCount" value="0" min="0" onchange="updateEstimate()">
                        <span>@ $</span>
                        <input type="number" id="shrubPrice" value="30" step="1" min="0" onchange="updateEstimate()">
                        <span>per strand</span>
                    </div>
                </div>
            </div>

            <!-- Right Panel - Estimate -->
            <div>
                <div class="estimate-box">
                    <h2>üí∞ ESTIMATE</h2>

                    <div class="estimate-item">
                        <div>
                            <label>Roofline Lights</label>
                            <div style="font-size: 0.9em; color: #666;" id="rooflineDetails">0 ft</div>
                        </div>
                        <div class="value" id="rooflineTotal">$0.00</div>
                    </div>

                    <div class="pricing-input" style="margin-left: 20px; margin-bottom: 15px;">
                        <span>Price per foot: $</span>
                        <input type="number" id="pricePerFoot" value="8" step="0.5" min="0" onchange="updateEstimate()">
                    </div>

                    <div class="estimate-item">
                        <div>
                            <label>Wreaths</label>
                            <div style="font-size: 0.9em; color: #666;" id="wreathDetails">None</div>
                        </div>
                        <div class="value" id="wreathTotal">$0.00</div>
                    </div>

                    <div class="estimate-item">
                        <div>
                            <label>Column Wraps</label>
                            <div style="font-size: 0.9em; color: #666;" id="columnDetails">0 wraps</div>
                        </div>
                        <div class="value" id="columnTotal">$0.00</div>
                    </div>

                    <div class="estimate-item">
                        <div>
                            <label>Shrub Wraps</label>
                            <div style="font-size: 0.9em; color: #666;" id="shrubDetails">0 wraps</div>
                        </div>
                        <div class="value" id="shrubTotal">$0.00</div>
                    </div>

                    <div class="estimate-total">
                        <h3>TOTAL ESTIMATE</h3>
                        <div class="total-value" id="grandTotal">$0.00</div>
                    </div>

                    <button class="btn-primary" onclick="exportPDF()" style="width: 100%; margin-top: 20px; padding: 15px; font-size: 1.1em;">
                        üìÑ Export to PDF
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let canvas, ctx;
        let image = null;
        let originalImageData = null; // Store original image without drawings
        let zoomLevel = 1;
        let calibrationPoints = [];
        let calibrationFactor = null;
        let isCalibrated = false;
        
        // History for undo/redo
        let history = [];
        let historyIndex = -1;
        
        let sections = [
            { color: '#ff0000', name: 'Section 1', points: [], lengths: [] },
            { color: '#ff8800', name: 'Section 2', points: [], lengths: [] },
            { color: '#00cc00', name: 'Section 3', points: [], lengths: [] },
            { color: '#0066ff', name: 'Section 4', points: [], lengths: [] },
            { color: '#cc00cc', name: 'Section 5', points: [], lengths: [] },
            { color: '#ff66cc', name: 'Section 6', points: [], lengths: [] }
        ];
        
        let currentSectionIndex = 0;
        let manualMeasurements = [];
        let wreaths = [];

        // Initialize
        document.getElementById('imageUpload').addEventListener('change', handleImageUpload);

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                originalImageData = event.target.result; // Store original image data
                image = new Image();
                image.onload = function() {
                    setupCanvas();
                    document.getElementById('canvasSection').style.display = 'block';
                    document.getElementById('instructionsCollapsible').style.display = 'block';
                };
                image.src = originalImageData;
            };
            reader.readAsDataURL(file);
        }

        function toggleInstructions() {
            const content = document.getElementById('instructionsContent');
            const toggle = document.getElementById('instructionsToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñ≤';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñº';
            }
        }

        function setupCanvas() {
            canvas = document.getElementById('measureCanvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas to actual image dimensions
            canvas.width = image.width;
            canvas.height = image.height;
            
            // CSS will automatically scale it to fit container
            
            drawCanvas();
            
            // Mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('click', handleCanvasClick);
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        // Touch event handlers
        let lastTouchTime = 0;

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            
            // Handle tap as click
            const now = Date.now();
            const timeSinceLastTouch = now - lastTouchTime;
            
            if (timeSinceLastTouch < 300 && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                const mouseEvent = new MouseEvent('click', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    bubbles: true
                });
                canvas.dispatchEvent(mouseEvent);
            }
            
            const mouseEvent = new MouseEvent('mouseup', {
                bubbles: true
            });
            canvas.dispatchEvent(mouseEvent);
            
            lastTouchTime = now;
        }

        let draggingPoint = null;
        let dragStartPos = null;

        function handleMouseDown(e) {
            if (!isCalibrated) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            // Larger detection radius on mobile to match larger points
            const isMobile = window.innerWidth < 768;
            const detectionRadius = isMobile ? 50 : 12;
            
            // Check if clicking on a point to drag
            for (let sectionIdx = 0; sectionIdx < sections.length; sectionIdx++) {
                const section = sections[sectionIdx];
                for (let pointIdx = 0; pointIdx < section.points.length; pointIdx++) {
                    const point = section.points[pointIdx];
                    const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                    
                    if (distance <= detectionRadius) { // Larger hit area on mobile
                        draggingPoint = { sectionIdx, pointIdx };
                        dragStartPos = { x, y };
                        canvas.style.cursor = 'move';
                        e.preventDefault();
                        return;
                    }
                }
            }
        }

        function handleMouseMove(e) {
            if (!draggingPoint) {
                // Update cursor when hovering over points
                if (isCalibrated) {
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    
                    const isMobile = window.innerWidth < 768;
                    const detectionRadius = isMobile ? 50 : 12;
                    
                    let overPoint = false;
                    for (let sectionIdx = 0; sectionIdx < sections.length; sectionIdx++) {
                        const section = sections[sectionIdx];
                        for (let pointIdx = 0; pointIdx < section.points.length; pointIdx++) {
                            const point = section.points[pointIdx];
                            const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                            
                            if (distance <= detectionRadius) {
                                overPoint = true;
                                break;
                            }
                        }
                        if (overPoint) break;
                    }
                    canvas.style.cursor = overPoint ? 'move' : 'crosshair';
                }
                return;
            }
            
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            // Update point position
            const section = sections[draggingPoint.sectionIdx];
            section.points[draggingPoint.pointIdx] = { x, y };
            
            // Recalculate lengths for affected segments
            const pointIdx = draggingPoint.pointIdx;
            
            // Recalculate segment before this point
            if (pointIdx > 0) {
                const p1 = section.points[pointIdx - 1];
                const p2 = section.points[pointIdx];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                section.lengths[pointIdx - 1] = pixelDistance * calibrationFactor;
            }
            
            // Recalculate segment after this point
            if (pointIdx < section.points.length - 1) {
                const p1 = section.points[pointIdx];
                const p2 = section.points[pointIdx + 1];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                section.lengths[pointIdx] = pixelDistance * calibrationFactor;
            }
            
            drawCanvas();
        }

        function handleMouseUp(e) {
            if (draggingPoint) {
                e.preventDefault();
                saveState(); // Save state after dragging
                draggingPoint = null;
                dragStartPos = null;
                canvas.style.cursor = 'crosshair';
                updateMeasurementsList();
                updateEstimate();
            }
        }

        function drawCanvas() {
            // Always start with a completely clean canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Redraw the base image
            ctx.drawImage(image, 0, 0);

            // Calculate point size based on viewport (MUCH larger on mobile)
            const isMobile = window.innerWidth < 768;
            const calibrationPointSize = isMobile ? 25 : 6;
            const measurePointSize = isMobile ? 30 : 8;
            const pointNumberFontSize = isMobile ? 24 : 12;
            const lineWidth = isMobile ? 8 : 3;

            // Draw calibration line
            if (calibrationPoints.length === 2) {
                ctx.strokeStyle = '#0066ff';
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.moveTo(calibrationPoints[0].x, calibrationPoints[0].y);
                ctx.lineTo(calibrationPoints[1].x, calibrationPoints[1].y);
                ctx.stroke();
                
                // Draw calibration points - MUCH larger on mobile
                calibrationPoints.forEach(point => {
                    // Yellow background for high visibility
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, calibrationPointSize + 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#0066ff';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, calibrationPointSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // White border for visibility
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = isMobile ? 4 : 2;
                    ctx.stroke();
                });
            }

            // Draw all sections - only draw what exists in the points array
            sections.forEach((section, sectionIdx) => {
                if (section.points.length === 0) return;

                ctx.strokeStyle = section.color;
                ctx.lineWidth = lineWidth;
                ctx.fillStyle = section.color;

                // Draw lines - THICKER on mobile
                for (let i = 0; i < section.points.length - 1; i++) {
                    if (section.points[i] && section.points[i + 1]) {
                        ctx.beginPath();
                        ctx.moveTo(section.points[i].x, section.points[i].y);
                        ctx.lineTo(section.points[i + 1].x, section.points[i + 1].y);
                        ctx.stroke();
                    }
                }

                // Draw points with numbers - MUCH larger on mobile
                section.points.forEach((point, idx) => {
                    if (point) {
                        // Yellow outer glow for visibility
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, measurePointSize + 5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = section.color;
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, measurePointSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // White border for visibility
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = isMobile ? 4 : 2;
                        ctx.stroke();
                        
                        ctx.fillStyle = 'white';
                        ctx.font = `bold ${pointNumberFontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText((idx + 1).toString(), point.x, point.y);
                    }
                });
            });

            // Draw length labels with X delete buttons on top of everything
            sections.forEach((section, sectionIdx) => {
                if (section.points.length === 0) return;
                
                // Clear delete areas for this section
                section.deleteAreas = [];

                // Larger labels and buttons on mobile
                const labelFontSize = isMobile ? 14 : 11;
                const xButtonSize = isMobile ? 24 : 16;
                const boxHeight = isMobile ? 24 : 16;

                for (let i = 0; i < section.points.length - 1; i++) {
                    if (section.lengths[i] && section.points[i] && section.points[i + 1]) {
                        const midX = (section.points[i].x + section.points[i + 1].x) / 2;
                        const midY = (section.points[i].y + section.points[i + 1].y) / 2;
                        
                        const labelText = section.lengths[i].toFixed(1) + ' ft';
                        ctx.font = `bold ${labelFontSize}px Arial`;
                        const textWidth = ctx.measureText(labelText).width;
                        
                        // Draw white background with rounded corners
                        const padding = isMobile ? 6 : 4;
                        const boxWidth = textWidth + padding * 2 + xButtonSize + 4;
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        ctx.beginPath();
                        ctx.roundRect(midX - boxWidth/2, midY - boxHeight/2, boxWidth, boxHeight, 3);
                        ctx.fill();
                        
                        // Draw text in dark color
                        ctx.fillStyle = '#333';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(labelText, midX - xButtonSize/2 - 2, midY);
                        
                        // Draw X button - larger on mobile
                        const xButtonX = midX + boxWidth/2 - xButtonSize/2 - 2;
                        const xButtonY = midY - xButtonSize/2;
                        
                        // Red circle background
                        ctx.fillStyle = '#dc3545';
                        ctx.beginPath();
                        const circleRadius = isMobile ? 11 : 7;
                        ctx.arc(xButtonX + xButtonSize/2, xButtonY + xButtonSize/2, circleRadius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // White X
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = isMobile ? 3 : 2;
                        const xOffset = isMobile ? 6 : 4;
                        ctx.beginPath();
                        ctx.moveTo(xButtonX + xOffset, xButtonY + xOffset);
                        ctx.lineTo(xButtonX + xButtonSize - xOffset, xButtonY + xButtonSize - xOffset);
                        ctx.moveTo(xButtonX + xButtonSize - xOffset, xButtonY + xOffset);
                        ctx.lineTo(xButtonX + xOffset, xButtonY + xButtonSize - xOffset);
                        ctx.stroke();
                        
                        // Store the clickable area for this segment - larger hit area on mobile
                        section.deleteAreas[i] = {
                            x: xButtonX - (isMobile ? 5 : 0),
                            y: xButtonY - (isMobile ? 5 : 0),
                            width: xButtonSize + (isMobile ? 10 : 0),
                            height: xButtonSize + (isMobile ? 10 : 0),
                            pointIndex: i
                        };
                    }
                }
            });
        }

        function handleCanvasClick(e) {
            // Don't process click if we just finished dragging
            if (dragStartPos) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                // If mouse moved more than 5 pixels, it was a drag not a click
                const distance = Math.sqrt((x - dragStartPos.x) ** 2 + (y - dragStartPos.y) ** 2);
                if (distance > 5) {
                    dragStartPos = null;
                    return;
                }
                dragStartPos = null;
            }
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // Check if clicking on an X button to delete a segment
            if (isCalibrated) {
                for (let sectionIdx = 0; sectionIdx < sections.length; sectionIdx++) {
                    const section = sections[sectionIdx];
                    if (!section.deleteAreas) continue;
                    
                    for (let i = 0; i < section.deleteAreas.length; i++) {
                        const area = section.deleteAreas[i];
                        if (!area) continue;
                        
                        if (x >= area.x && x <= area.x + area.width &&
                            y >= area.y && y <= area.y + area.height) {
                            // Delete this segment
                            deleteSegment(sectionIdx, area.pointIndex);
                            return;
                        }
                    }
                }
                
                // Check if clicking near an existing point (to avoid accidental new points)
                const isMobile = window.innerWidth < 768;
                const detectionRadius = isMobile ? 50 : 12;
                
                for (let sectionIdx = 0; sectionIdx < sections.length; sectionIdx++) {
                    const section = sections[sectionIdx];
                    for (let pointIdx = 0; pointIdx < section.points.length; pointIdx++) {
                        const point = section.points[pointIdx];
                        const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                        
                        if (distance <= detectionRadius) {
                            // Clicking on existing point, don't add new one
                            return;
                        }
                    }
                }
            }

            if (!isCalibrated) {
                // Calibration mode
                calibrationPoints.push({ x, y });
                
                if (calibrationPoints.length === 2) {
                    const dx = calibrationPoints[1].x - calibrationPoints[0].x;
                    const dy = calibrationPoints[1].y - calibrationPoints[0].y;
                    const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                    const knownDistance = parseFloat(document.getElementById('knownDistance').value);
                    
                    calibrationFactor = knownDistance / pixelDistance;
                    isCalibrated = true;
                    
                    document.getElementById('calibrationStatus').className = 'status success';
                    document.getElementById('calibrationStatus').textContent = 
                        `‚úì Calibrated! 1 pixel = ${calibrationFactor.toFixed(4)} feet`;
                }
                
                drawCanvas();
            } else {
                // Measurement mode
                const currentSection = sections[currentSectionIndex];
                currentSection.points.push({ x, y });
                
                if (currentSection.points.length > 1) {
                    const lastIdx = currentSection.points.length - 1;
                    const p1 = currentSection.points[lastIdx - 1];
                    const p2 = currentSection.points[lastIdx];
                    
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                    const feetDistance = pixelDistance * calibrationFactor;
                    
                    currentSection.lengths.push(feetDistance);
                }
                
                saveState(); // Save state for undo/redo
                drawCanvas();
                updateMeasurementsList();
                updateEstimate();
            }
        }

        function deleteSegment(sectionIdx, pointIndex) {
            if (!confirm('Delete this segment? This will remove the point and line.')) return;
            
            saveState(); // Save state before deleting
            
            const section = sections[sectionIdx];
            
            // Remove the second point of the segment
            section.points.splice(pointIndex + 1, 1);
            
            // Completely rebuild lengths and delete areas for this section
            section.lengths = [];
            section.deleteAreas = [];
            
            // Recalculate all lengths from scratch
            for (let i = 0; i < section.points.length - 1; i++) {
                const p1 = section.points[i];
                const p2 = section.points[i + 1];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                const feetDistance = pixelDistance * calibrationFactor;
                section.lengths.push(feetDistance);
            }
            
            // Clear all delete areas for all sections
            sections.forEach(s => s.deleteAreas = []);
            
            // Force a complete redraw - clear canvas completely first
            if (canvas && ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                drawCanvas();
                ctx.restore();
            }
            
            updateMeasurementsList();
            updateEstimate();
        }

        function resetCalibration() {
            calibrationPoints = [];
            isCalibrated = false;
            document.getElementById('calibrationStatus').className = 'status info';
            document.getElementById('calibrationStatus').textContent = 
                'Click two points on a known distance (door, window, etc.)';
            drawCanvas();
        }

        function startNewSection() {
            if (!isCalibrated) {
                alert('Please calibrate first!');
                return;
            }
            
            currentSectionIndex++;
            if (currentSectionIndex >= sections.length) {
                alert('Maximum 6 sections reached!');
                currentSectionIndex = sections.length - 1;
                return;
            }
            
            updateMeasurementsList();
        }

        function saveState() {
            // Save current state to history
            const state = {
                sections: sections.map(section => ({
                    color: section.color,
                    name: section.name,
                    points: JSON.parse(JSON.stringify(section.points)),
                    lengths: JSON.parse(JSON.stringify(section.lengths))
                })),
                currentSectionIndex: currentSectionIndex
            };
            
            // Remove any states after current index (if we undid and then made changes)
            history = history.slice(0, historyIndex + 1);
            
            // Add new state
            history.push(state);
            historyIndex++;
            
            // Limit history to 50 states
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }
        }

        function restoreState(state) {
            sections = state.sections.map(section => ({
                color: section.color,
                name: section.name,
                points: JSON.parse(JSON.stringify(section.points)),
                lengths: JSON.parse(JSON.stringify(section.lengths)),
                deleteAreas: []
            }));
            currentSectionIndex = state.currentSectionIndex;
            
            drawCanvas();
            updateMeasurementsList();
            updateEstimate();
        }

        function undoPoint() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(history[historyIndex]);
            } else {
                alert('Nothing to undo!');
            }
        }

        function redoPoint() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState(history[historyIndex]);
            } else {
                alert('Nothing to redo!');
            }
        }

        function clearAll() {
            if (confirm('Clear all measurements?')) {
                sections.forEach(section => {
                    section.points = [];
                    section.lengths = [];
                    section.deleteAreas = [];
                });
                currentSectionIndex = 0;
                
                // Force complete canvas clear and redraw
                if (canvas && ctx && image) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(image, 0, 0);
                    
                    // Redraw calibration if it exists
                    if (calibrationPoints.length === 2) {
                        ctx.strokeStyle = '#0066ff';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(calibrationPoints[0].x, calibrationPoints[0].y);
                        ctx.lineTo(calibrationPoints[1].x, calibrationPoints[1].y);
                        ctx.stroke();
                        
                        calibrationPoints.forEach(point => {
                            ctx.fillStyle = '#0066ff';
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                            ctx.fill();
                        });
                    }
                }
                
                updateMeasurementsList();
                updateEstimate();
            }
        }

        function zoomIn() {
            zoomLevel += 0.2;
            canvas.style.transform = `scale(${zoomLevel})`;
            canvas.style.transformOrigin = 'top left';
        }

        function zoomOut() {
            zoomLevel = Math.max(0.5, zoomLevel - 0.2);
            canvas.style.transform = `scale(${zoomLevel})`;
            canvas.style.transformOrigin = 'top left';
        }

        function updateMeasurementsList() {
            const list = document.getElementById('measurementsList');
            list.innerHTML = '';
            
            sections.forEach((section, idx) => {
                if (section.points.length > 0) {
                    const total = section.lengths.reduce((sum, len) => sum + len, 0);
                    const colorClass = section.color.replace('#', '');
                    
                    const div = document.createElement('div');
                    div.className = `measurement-item ${getColorName(section.color)}`;
                    div.innerHTML = `
                        <div>
                            <strong>${section.name}</strong>: ${section.points.length} points
                        </div>
                        <div style="font-weight: bold;">${total.toFixed(1)} ft</div>
                    `;
                    list.appendChild(div);
                }
            });
        }

        function getColorName(hex) {
            const colors = {
                '#ff0000': 'red',
                '#ff8800': 'orange',
                '#00cc00': 'green',
                '#0066ff': 'blue',
                '#cc00cc': 'purple',
                '#ff66cc': 'pink'
            };
            return colors[hex] || 'red';
        }

        function addManualMeasurement() {
            const id = Date.now();
            manualMeasurements.push({ id, label: '', length: 0 });
            renderManualMeasurements();
        }

        function renderManualMeasurements() {
            const container = document.getElementById('manualMeasurements');
            container.innerHTML = '';
            
            manualMeasurements.forEach(item => {
                const div = document.createElement('div');
                div.className = 'manual-measurement';
                div.innerHTML = `
                    <input type="text" placeholder="Label (e.g., 'Back wall')" 
                           value="${item.label}" 
                           onchange="updateManualLabel(${item.id}, this.value)">
                    <input type="number" placeholder="Length in feet" 
                           value="${item.length}" step="0.5" min="0"
                           onchange="updateManualLength(${item.id}, this.value)">
                    <button class="remove-btn" onclick="removeManualMeasurement(${item.id})">Remove</button>
                `;
                container.appendChild(div);
            });
        }

        function updateManualLabel(id, value) {
            const item = manualMeasurements.find(m => m.id === id);
            if (item) {
                item.label = value;
                updateEstimate();
            }
        }

        function updateManualLength(id, value) {
            const item = manualMeasurements.find(m => m.id === id);
            if (item) {
                item.length = parseFloat(value) || 0;
                updateEstimate();
            }
        }

        function removeManualMeasurement(id) {
            manualMeasurements = manualMeasurements.filter(m => m.id !== id);
            renderManualMeasurements();
            updateEstimate();
        }

        function addWreath() {
            const id = Date.now();
            wreaths.push({ id, size: '24', quantity: 1, price: 25 });
            renderWreaths();
        }

        function renderWreaths() {
            const container = document.getElementById('wreathsList');
            container.innerHTML = '';
            
            wreaths.forEach(wreath => {
                const div = document.createElement('div');
                div.className = 'wreath-entry';
                div.innerHTML = `
                    <label>Size:</label>
                    <select onchange="updateWreathSize(${wreath.id}, this.value)">
                        <option value="24" ${wreath.size === '24' ? 'selected' : ''}>24 inch</option>
                        <option value="36" ${wreath.size === '36' ? 'selected' : ''}>36 inch</option>
                        <option value="48" ${wreath.size === '48' ? 'selected' : ''}>48 inch</option>
                    </select>
                    <label>Quantity:</label>
                    <input type="number" value="${wreath.quantity}" min="1" 
                           onchange="updateWreathQuantity(${wreath.id}, this.value)">
                    <label>Price Each: $</label>
                    <input type="number" value="${wreath.price}" step="1" min="0"
                           onchange="updateWreathPrice(${wreath.id}, this.value)">
                    <button class="remove-btn" onclick="removeWreath(${wreath.id})">Remove</button>
                `;
                container.appendChild(div);
            });
            
            updateEstimate();
        }

        function updateWreathSize(id, size) {
            const wreath = wreaths.find(w => w.id === id);
            if (wreath) {
                wreath.size = size;
                updateEstimate();
            }
        }

        function updateWreathQuantity(id, quantity) {
            const wreath = wreaths.find(w => w.id === id);
            if (wreath) {
                wreath.quantity = parseInt(quantity) || 1;
                updateEstimate();
            }
        }

        function updateWreathPrice(id, price) {
            const wreath = wreaths.find(w => w.id === id);
            if (wreath) {
                wreath.price = parseFloat(price) || 0;
                updateEstimate();
            }
        }

        function removeWreath(id) {
            wreaths = wreaths.filter(w => w.id !== id);
            renderWreaths();
        }

        function updateEstimate() {
            // Calculate roofline total
            let rooflineFootage = 0;
            sections.forEach(section => {
                rooflineFootage += section.lengths.reduce((sum, len) => sum + len, 0);
            });
            
            manualMeasurements.forEach(item => {
                rooflineFootage += item.length;
            });
            
            const pricePerFoot = parseFloat(document.getElementById('pricePerFoot').value) || 0;
            const rooflineTotal = rooflineFootage * pricePerFoot;
            
            document.getElementById('rooflineDetails').textContent = `${rooflineFootage.toFixed(1)} ft √ó $${pricePerFoot}/ft`;
            document.getElementById('rooflineTotal').textContent = `$${rooflineTotal.toFixed(2)}`;

            // Calculate wreath total
            let wreathTotal = 0;
            let wreathDetailsText = [];
            wreaths.forEach(wreath => {
                const subtotal = wreath.quantity * wreath.price;
                wreathTotal += subtotal;
                wreathDetailsText.push(`${wreath.quantity} √ó ${wreath.size}" @ $${wreath.price} each`);
            });
            
            document.getElementById('wreathDetails').textContent = 
                wreathDetailsText.length > 0 ? wreathDetailsText.join(', ') : 'None';
            document.getElementById('wreathTotal').textContent = `$${wreathTotal.toFixed(2)}`;

            // Calculate column wraps
            const columnCount = parseInt(document.getElementById('columnCount').value) || 0;
            const columnPrice = parseFloat(document.getElementById('columnPrice').value) || 0;
            const columnTotal = columnCount * columnPrice;
            
            document.getElementById('columnDetails').textContent = `${columnCount} wraps`;
            document.getElementById('columnTotal').textContent = `$${columnTotal.toFixed(2)}`;

            // Calculate shrub wraps
            const shrubCount = parseInt(document.getElementById('shrubCount').value) || 0;
            const shrubPrice = parseFloat(document.getElementById('shrubPrice').value) || 0;
            const shrubTotal = shrubCount * shrubPrice;
            
            document.getElementById('shrubDetails').textContent = `${shrubCount} wraps`;
            document.getElementById('shrubTotal').textContent = `$${shrubTotal.toFixed(2)}`;

            // Grand total
            const grandTotal = rooflineTotal + wreathTotal + columnTotal + shrubTotal;
            document.getElementById('grandTotal').textContent = `$${grandTotal.toFixed(2)}`;
        }

        function exportPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            const customerName = document.getElementById('customerName').value || 'Customer';
            const customerAddress = document.getElementById('customerAddress').value || '';
            
            // Title
            doc.setFontSize(22);
            doc.setTextColor(44, 95, 45);
            doc.text('Christmas Light Installation Quote', 105, 20, { align: 'center' });
            
            // Customer info
            doc.setFontSize(12);
            doc.setTextColor(0, 0, 0);
            doc.text(`Customer: ${customerName}`, 20, 40);
            doc.text(`Address: ${customerAddress}`, 20, 48);
            doc.text(`Date: ${new Date().toLocaleDateString()}`, 20, 56);
            
            // Line
            doc.setDrawColor(44, 95, 45);
            doc.setLineWidth(0.5);
            doc.line(20, 62, 190, 62);
            
            let yPos = 75;
            
            // Add measured image if available
            if (canvas && image) {
                doc.setFontSize(14);
                doc.setTextColor(44, 95, 45);
                doc.text('Measured Roof Photo:', 20, yPos);
                yPos += 8;
                
                // Get canvas as image
                const canvasImage = canvas.toDataURL('image/jpeg', 0.7);
                
                // Calculate dimensions to fit on page
                const maxWidth = 170;
                const maxHeight = 100;
                let imgWidth = canvas.width;
                let imgHeight = canvas.height;
                
                // Scale to fit
                const ratio = Math.min(maxWidth / imgWidth, maxHeight / imgHeight);
                imgWidth = imgWidth * ratio;
                imgHeight = imgHeight * ratio;
                
                doc.addImage(canvasImage, 'JPEG', 20, yPos, imgWidth, imgHeight);
                yPos += imgHeight + 15;
                
                // Add new page if needed
                if (yPos > 200) {
                    doc.addPage();
                    yPos = 20;
                }
            }
            
            // Roofline
            const rooflineFootage = sections.reduce((sum, s) => 
                sum + s.lengths.reduce((s2, l) => s2 + l, 0), 0) + 
                manualMeasurements.reduce((sum, m) => sum + m.length, 0);
            const pricePerFoot = parseFloat(document.getElementById('pricePerFoot').value) || 0;
            const rooflineTotal = rooflineFootage * pricePerFoot;
            
            doc.setFontSize(14);
            doc.text('Roofline Lights:', 20, yPos);
            doc.text(`${rooflineFootage.toFixed(1)} ft √ó $${pricePerFoot}/ft`, 80, yPos);
            doc.text(`$${rooflineTotal.toFixed(2)}`, 160, yPos, { align: 'right' });
            yPos += 10;
            
            // Wreaths
            if (wreaths.length > 0) {
                doc.text('Wreaths:', 20, yPos);
                yPos += 8;
                wreaths.forEach(wreath => {
                    doc.setFontSize(11);
                    const subtotal = wreath.quantity * wreath.price;
                    doc.text(`  ${wreath.quantity} √ó ${wreath.size}" @ $${wreath.price}`, 25, yPos);
                    doc.text(`$${subtotal.toFixed(2)}`, 160, yPos, { align: 'right' });
                    yPos += 7;
                });
                yPos += 3;
            }
            
            // Columns
            const columnCount = parseInt(document.getElementById('columnCount').value) || 0;
            const columnPrice = parseFloat(document.getElementById('columnPrice').value) || 0;
            const columnTotal = columnCount * columnPrice;
            
            if (columnCount > 0) {
                doc.setFontSize(14);
                doc.text('Column Wraps:', 20, yPos);
                doc.text(`${columnCount} √ó $${columnPrice}`, 80, yPos);
                doc.text(`$${columnTotal.toFixed(2)}`, 160, yPos, { align: 'right' });
                yPos += 10;
            }
            
            // Shrubs
            const shrubCount = parseInt(document.getElementById('shrubCount').value) || 0;
            const shrubPrice = parseFloat(document.getElementById('shrubPrice').value) || 0;
            const shrubTotal = shrubCount * shrubPrice;
            
            if (shrubCount > 0) {
                doc.setFontSize(14);
                doc.text('Shrub Wraps:', 20, yPos);
                doc.text(`${shrubCount} √ó $${shrubPrice}`, 80, yPos);
                doc.text(`$${shrubTotal.toFixed(2)}`, 160, yPos, { align: 'right' });
                yPos += 10;
            }
            
            // Total
            yPos += 5;
            doc.setDrawColor(44, 95, 45);
            doc.line(20, yPos, 190, yPos);
            yPos += 10;
            
            doc.setFontSize(18);
            doc.setTextColor(44, 95, 45);
            const grandTotal = rooflineTotal + wreaths.reduce((sum, w) => sum + (w.quantity * w.price), 0) + 
                              columnTotal + shrubTotal;
            doc.text('TOTAL:', 20, yPos);
            doc.text(`$${grandTotal.toFixed(2)}`, 190, yPos, { align: 'right' });
            
            // Save
            const filename = `${customerName.replace(/\s+/g, '_')}_ChristmasLights_Quote.pdf`;
            doc.save(filename);
        }

        // Project Save/Load Functions
        function saveProject() {
            const customerName = document.getElementById('customerName').value || 'Untitled';
            
            // Create project data object
            const projectData = {
                version: '1.0',
                customerName: document.getElementById('customerName').value,
                customerAddress: document.getElementById('customerAddress').value,
                calibrationFactor: calibrationFactor,
                calibrationPoints: calibrationPoints,
                isCalibrated: isCalibrated,
                knownDistance: document.getElementById('knownDistance').value,
                sections: sections.map(section => ({
                    color: section.color,
                    name: section.name,
                    points: section.points,
                    lengths: section.lengths
                })),
                currentSectionIndex: currentSectionIndex,
                manualMeasurements: manualMeasurements,
                wreaths: wreaths,
                columnCount: document.getElementById('columnCount').value,
                columnPrice: document.getElementById('columnPrice').value,
                shrubCount: document.getElementById('shrubCount').value,
                shrubPrice: document.getElementById('shrubPrice').value,
                pricePerFoot: document.getElementById('pricePerFoot').value,
                imageData: originalImageData, // Save original image, not canvas with drawings
                timestamp: new Date().toISOString()
            };

            // Convert to JSON and create download
            const jsonString = JSON.stringify(projectData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${customerName.replace(/\s+/g, '_')}_Project.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('Project saved! You can load this file later to continue editing.');
        }

        function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const projectData = JSON.parse(event.target.result);
                        
                        // Validate project data
                        if (!projectData.version) {
                            alert('Invalid project file!');
                            return;
                        }
                        
                        // Restore customer information
                        document.getElementById('customerName').value = projectData.customerName || '';
                        document.getElementById('customerAddress').value = projectData.customerAddress || '';
                        
                        // Restore calibration
                        calibrationFactor = projectData.calibrationFactor;
                        calibrationPoints = projectData.calibrationPoints || [];
                        isCalibrated = projectData.isCalibrated || false;
                        document.getElementById('knownDistance').value = projectData.knownDistance || 8;
                        
                        if (isCalibrated) {
                            document.getElementById('calibrationStatus').className = 'status success';
                            document.getElementById('calibrationStatus').textContent = 
                                `‚úì Calibrated! 1 pixel = ${calibrationFactor.toFixed(4)} feet`;
                        }
                        
                        // Restore sections - make sure to clear deleteAreas
                        sections = projectData.sections.map(section => ({
                            color: section.color,
                            name: section.name,
                            points: section.points || [],
                            lengths: section.lengths || [],
                            deleteAreas: [] // Clear this to force recalculation
                        }));
                        currentSectionIndex = projectData.currentSectionIndex || 0;
                        
                        // Restore manual measurements
                        manualMeasurements = projectData.manualMeasurements || [];
                        renderManualMeasurements();
                        
                        // Restore wreaths
                        wreaths = projectData.wreaths || [];
                        renderWreaths();
                        
                        // Restore pricing
                        document.getElementById('columnCount').value = projectData.columnCount || 0;
                        document.getElementById('columnPrice').value = projectData.columnPrice || 40;
                        document.getElementById('shrubCount').value = projectData.shrubCount || 0;
                        document.getElementById('shrubPrice').value = projectData.shrubPrice || 30;
                        document.getElementById('pricePerFoot').value = projectData.pricePerFoot || 8;
                        
                        // Restore image
                        if (projectData.imageData) {
                            originalImageData = projectData.imageData; // Restore original image data
                            image = new Image();
                            image.onload = function() {
                                // Setup canvas with event listeners
                                canvas = document.getElementById('measureCanvas');
                                ctx = canvas.getContext('2d');
                                
                                canvas.width = image.width;
                                canvas.height = image.height;
                                
                                // CRITICAL: Clear the entire canvas first
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                
                                // Remove old event listeners if they exist
                                const newCanvas = canvas.cloneNode(true);
                                canvas.parentNode.replaceChild(newCanvas, canvas);
                                canvas = newCanvas;
                                ctx = canvas.getContext('2d');
                                
                                // Clear again after cloning
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                
                                // Add event listeners
                                canvas.addEventListener('mousedown', handleMouseDown);
                                canvas.addEventListener('mousemove', handleMouseMove);
                                canvas.addEventListener('mouseup', handleMouseUp);
                                canvas.addEventListener('click', handleCanvasClick);
                                
                                // Touch events for mobile
                                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
                                
                                document.getElementById('canvasSection').style.display = 'block';
                                document.getElementById('instructionsCollapsible').style.display = 'block';
                                
                                // Draw everything fresh
                                drawCanvas();
                                updateMeasurementsList();
                                updateEstimate();
                            };
                            image.src = originalImageData;
                        } else {
                            // No image data, but still update UI
                            updateMeasurementsList();
                            updateEstimate();
                        }
                        
                        alert('Project loaded successfully! You can now edit measurements, delete points, or update pricing.');
                        
                    } catch (error) {
                        alert('Error loading project file: ' + error.message);
                        console.error('Load error:', error);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }
    </script>
</body>
</html>
